<!DOCTYPE html>
<html lang="en">
<head>
        <title>Tech blog by @dizballanze - очередь сообщений</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="/theme/css/app.css" type="text/css" />
        <link href="http://dizballanze.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tech blog by @dizballanze Atom Feed" />
        <link href="http://dizballanze.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Tech blog by @dizballanze RSS Feed" />
        <link href="/static/icons/favicon.ico" rel="icon" type="image/x-icon" />
        <link href="/static/icons/favicon.ico" rel="shortcut icon" type="image/x-icon" />
        
        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie.css"/>
                <script src="/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ru_RU/all.js#xfbml=1&appId=143995599087385";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<a href="https://github.com/dizballanze">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="/">Tech blog by @dizballanze </a></h1>
                <nav><ul>
                    <li><a href="/автор/">Автор</a></li>
                    <li ><a href="/category/bd.html">БД</a></li>
                    <li ><a href="/category/drugoe.html">Другое</a></li>
                    <li ><a href="/category/linux.html">Linux</a></li>
                    <li ><a href="/category/nodejs.html">Node.js</a></li>
                    <li ><a href="/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->
        
        

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/">Очередь сообщений на node.js и memcacheq</a></h1> 
<footer class="post-info">
        <abbr class="published" title="2011-10-07T23:24:00+04:00">
                пт 07 октября 2011
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/memcacheq/">memcacheq</a><a href="/tag/nodejs/">node.js</a><a href="/tag/php/">PHP</a><a href="/tag/ochered-soobshchenii/">очередь сообщений</a></p>
</footer><!-- /.post-info --><p>Привет! Столкнулся с необходимостью использования очередей сообщений в
текущем проекте. Знаю что есть готовые решения, но я все же решил
написать свой небольшой велосипед. Итак, поехали...</p>
<h2 id="_1">Описание</h2>
<p><img alt="scheme" src="/media/2011/10/png" /></p>
<p>В поставленной передо мной задаче необходимо выполнять ресурсоемкие
операции (такие как работа с сетью, декодирование mp3-файлов), а также
обращаться к бизнес-логике приложения для потока входных данных.
Приложение написано на php, поэтому очевидно что удобнее всего писать
worker'ы на этом языке в виде cli скриптов. В моем случае это сделать
очень просто, т.к. в проекте используется yii, а в нем есть
замечательная поддержка написания консольных команд при этом можно
использовать весь код бизнес-логики используемый в основном приложении.</p>
<p>Для реализации хранения заданий отличным решением стало memcacheq.
Memcacheq - это сервис поддержки очередей с использованием api
memcached. Подробнее узнать о том что это за зверь можете на <a href="http://memcachedb.org/memcacheq/">офф.
сайте</a>. Стоит отметить что в связи с использованием BerkleyDB в
memcacheq есть ограничение на размер сообщения в очереди, которое
составляет около 64Кб, если для вас этого мало, то стоит подумать о
другом решении.</p>
<p>Также потребуется менеджер очереди, который будет контролировать работу
воркеров (порождать, отслеживать статус выполнения, получать
результаты). Очевидно что менеджер должен работать постоянно и
периодически проверять нет ли новых заданий. Для реализации менеджера я
выбрал Node.js, как мне кажется это очень подходящая технология для этих
целей. В основном выбор пал на node из-за его асинхронности, возможности
легко и быстро написать демон, который будет вписываться в архитектуру
проекта и также на меня повлиял предыдущий опыт работы с данной
технологией, который оставил в основном положительные впечатления.</p>
<h2 id="_2">Реализация</h2>
<p>На данном этапе у вас уже должен быть настроен и запущен memcacheq,
установлен nodejs. Также нам понадобиться модуль nodejs под названием
memcached. Установить его можно следующей командой:</p>
<pre><code>:::bash
npm install memcached
</code></pre>
<p>Основные составляющие части менеджера очереди:</p>
<ul>
<li>Бесконечный цикл опроса очереди на наличие заданий. При этом также в
    цикле должна проводиться проверка на состояние запущенных worker'ов.
    Т.к. мы не можем себе позволить создание worker'ов в таком
    количестве в котором доступны задания, то нам необходимо ввести
    ограничение на количество одновременно обрабатываемых заданий. В
    данном цикле перед созданием новых потоков проверяется наличие
    свободного места, т.е. worker создается только в случае если
    количество текущих worker'ов меньше установленного ограничения.</li>
<li>Объект worker'а - представляет из себя оболочку над процессом
    worker'а и хранит его состояние.</li>
<li>Создание worker'а - процесс инициализации объекта worker'а на основе
    данных полученных от memcacheq</li>
<li>Мониторинг. Для отслеживания состояния выполнения заданий создадим
    web-сервер который будет отвечать информацией о текущем статусе
    выполнения каждого выполняемого worker'а.</li>
<li>Т.к. в моя задача связанна с передачей большого объема данных, то
    появилось необходимость ввести поправку на возможную ошибку передачи
    данных. Это подразумевает повторное занесение задания в очередь в
    случае если worker вернет ошибку передачи, которая может быть
    определена проверкой контрольной суммы передаваемых данных.</li>
</ul>
<p>Теперь собственно исходный код:</p>
<pre><code>:::javascript
var util = require('util'),
    exec = require('child_process').exec;

var http = require('http');
var Memcached = require('./lib/memcached.js');
var memcached = new Memcached('127.0.0.1:22201', {maxValue:65000, reconnect:2000, retry:1000, timeout:10000});

var creating = false;
var workers_count = 2;
var transmit_error_retry_count = 3;
var workers = {};
var tasks = {};
var transmit_errors = {};
var command_line = '/path/to/worker/script';

// Возможные состояния процесса
var WORKER_SUCCESS_DONE = 1,
    WORKER_TRANSMIT_ERROR = 2,
    WORKER_CRITICAL_ERROR = 3,
    WORKER_IN_WORKING_PROCESS = 4;

// Функция выполняемая в бесконечном цикле
function check_feeds(){
    for (i in workers){
        if (workers[i].status == WORKER_SUCCESS_DONE){
            if (transmit_errors[i] != undefined)
                delete transmit_errors[i];
            delete workers[i];
            delete tasks[i];
        }else if(workers[i].status == WORKER_TRANSMIT_ERROR){
            if (transmit_errors[i] == undefined)
                transmit_errors[i] = 1;
            else
                transmit_errors[i]++;
            if (transmit_errors[i] &lt; transmit_error_retry_count)
                push_back(tasks[i]);
            else{
                delete transmit_errors[i];
                delete tasks[i];
            }
            delete workers[i];
        }else if (workers[i].status != WORKER_IN_WORKING_PROCESS){
            if (transmit_errors[i] != undefined)
                delete transmit_errors[i];
            delete workers[i];
        }
    }

    // Если есть свободные места вызываем функцию
    // создающую worker'ов
    if (!creating &amp;&amp; (obj_count(workers) &lt; workers_count))
        create_worker();
}

// Возвращение задания в очередь
function push_back(task){
    memcached.set("tracks", task, 0);
}

// Функция выполняющая создание новых worker'ов
function create_worker(){
    creating = true;
    memcached.get("tracks", function(err, result){
        if (!result)
            creating = false;
        else{
            check_feeds();
            work = JSON.parse(result);
            tasks[work['id']] = work;
            workers[work['id']] = new Worker(work);
            // Если все ещё есть свободные места
            // то делаем рекурсивный вызов
            if (obj_count(workers) &lt; workers_count){
                create_worker();
            }else{
                creating = false;
            }
        }
    });
}

// Конструктор объекта worker'а
function Worker(id, data){
    this.status = WORKER_IN_WORKING_PROCESS;

    // Здесь можно сформировать 
    // параметры командной строки
    var params;

    exec(command_line + params, function(err, data){
        console.log(id, data);
        if (err)
            workers[id].status = WORKER_CRITICAL_ERROR;
        else
            workers[id].status = data;
    })
}

setInterval(function(){
    check_feeds();
}, 100);

// Monitoring server
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    for (i in workers){
        res.write(i +': ' + workers[i].status + "\n");
    }
    // Для того чтобы заработал след. код
    // необходимо внести изменения
    // в модуль memcache (см. ниже)
    memcached.queue(function (err, result){
        res.end('Queue:' + result);
    });
}).listen(8080, "127.0.0.1");

// Stuff
function obj_count(obj){
    var i = 0;
    for (j in obj) i++;
    return i;
}
</code></pre>
<p>Для того чтобы корректно обрабатывать статусы выполнения задания
worker'ы должны возвращать определенные заранее значения. В моем случае
worker может вернуть одно из 3х состояний обозначенных в начале
исходного кода.</p>
<p>Также стоит отметить, что для реализации отображения количества задач в
очереди memcacheq необходимо выполнить запрос stats queue, но модуль
memcached по всей видимости его не поддерживает. По-этому я внес
небольшие дополнения чтобы реализовать данный функционал. Исходный код
модуля доступен <a href="http://pastebin.com/MgSFU6Gb">по ссылке</a>.</p>
<h2 id="in-the-end">In the end..</h2>
<p>Стоит заметить, что при помощи подобной организации системы вы сможете
распараллелить ресурсоемкие вычисления. Особенно это удобно, когда вам
необходимо обращаться к бизнес-логике написанной, например, на PHP. В
завершении хочу добавить что полученная система очереди сообщений сильно
направленная на реализацию поставленной передо мной задачи. Но я считаю,
что вы без проблем сможете доработать код для реализации нужного вам
функционала. Спасибо за внимание, буду рад ответить на возникшие
вопросы.</p><p><a href="/nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/#disqus_thread">comments</a></p>                </article>
<p class="paginator">
    Страница 1 / 1
</p>
            </aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
            </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>ссылки</h2>
                        <ul>
                            <li><a href="http://wbtech.pro">WBTech</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>онлайн</h2>
                        <ul>
                            <li><a href="http://dizballanze.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="http://dizballanze.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                            <li><a href="https://twitter.com/dizballanze">Twitter</a></li>
                            <li><a href="https://github.com/dizballanze">GitHub</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Powered by <a href="http://getpelican.com/">Pelican</a>, <a href="http://python.org">Python</a>.
                <section class="right">&copy; <a href="/avtor">Yuri Shikanov</a> 2010-2015</section>
                </address><!-- /#about -->

        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-20497524-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'dizballanze';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>