<!DOCTYPE html>
<html lang="en">
<head>
        <title>Tech blog by @dizballanze - Node.js</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="/theme/css/app.css" type="text/css" />
        <link href="http://dizballanze.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tech blog by @dizballanze Atom Feed" />
        <link href="http://dizballanze.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Tech blog by @dizballanze RSS Feed" />
        <link href="/static/icons/favicon.ico" rel="icon" type="image/x-icon" />
        <link href="/static/icons/favicon.ico" rel="shortcut icon" type="image/x-icon" />
        
        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie.css"/>
                <script src="/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ru_RU/all.js#xfbml=1&appId=143995599087385";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<a href="https://github.com/dizballanze">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="/">Tech blog by @dizballanze </a></h1>
                <nav><ul>
                    <li><a href="/avtor/">Автор</a></li>
                    <li ><a href="/category/bd.html">БД</a></li>
                    <li ><a href="/category/drugoe.html">Другое</a></li>
                    <li ><a href="/category/linux.html">Linux</a></li>
                    <li class="active"><a href="/category/nodejs.html">Node.js</a></li>
                    <li ><a href="/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->
        
        

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/nodejs/servernaia-arkhitektura-debugmail/">Серверная архитектура DebugMail</a></h1> 
<footer class="post-info">
        <abbr class="published" title="2014-03-15T23:46:00+04:00">
                сб 15 марта 2014
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/nodejs/">node.js</a><a href="/tag/mongodb/">mongodb</a><a href="/tag/faye/">faye</a><a href="/tag/debugmail/">debugmail</a></p>
</footer><!-- /.post-info --><p><img alt="debugmail-logo" src="/media/2014/3/debugmail.jpg" title="DebugMail" /></p>
<p>На днях <a href="http://wbtech.ru">мы</a> запустили <a href="http://debugmail.io/">DebugMail</a> - сервис, который помогает упростить тестирование email-рассылок на этапе разработки сайта/приложения/etc. Сервис позволяет сразу после регистрации получить свой виртуальный smtp-сервер, просматривать отправляемые письма, совместно работать над рассылками вместе с коллегами. В этом посте я расскажу про то, как разрабатывался backend сервиса, какие технологии использовались и какие проблемы приходилось решать. Думаю пост будет интересен прежде всего тем, кто работает с Node.js. </p>
<p>Основные используемые технологии:</p>
<ul>
<li><a href="http://nodejs.org/">Node.js</a> для запуска нашего js на сервере.</li>
<li><a href="http://coffeescript.org/">CoffeeScript</a>, чтобы добавить немного сахара к нашему js.</li>
<li><a href="https://www.mongodb.org/">MongoDB</a> для хранения всех перманентных данных. <a href="http://mongoosejs.com/">Mongoose</a> - ODM для работы с MongoDB из под Node.js.</li>
<li><a href="http://redis.io/">Redis</a>, как хранилище для сессий, кэш и для поддержки работы сервера real-time обновлений (<a href="http://redis.io/topics/pubsub">pub/sub</a>).</li>
<li><a href="http://faye.jcoglan.com/">Faye</a> система для обмена real-time сообщениями между клиентом и сервером при помощи паттерна pub/sub.</li>
</ul>
<p>Backend сервиса состоит 3 основных компонентов:</p>
<ul>
<li>SMTP-сервер, который сохраняет все полученные письма и умеет отличать проект к которому относится письмо.</li>
<li>REST Api который позволяет выполнять операции по работе с проектами, пользователями и письмами.</li>
<li>Сервер для поддержки real-time обновлений при получении новых писем.</li>
</ul>
<p>Для того, чтобы сервис было легче масштабировать, каждый из описанных выше компонентов разрабатывался с учетом того, что он может быть запущен отдельно, в том числе на другом сервере. Взаимодействие между компонентами в основном происходит через базу данных и систему обмена сообщениями Faye (для real-time обновлений).</p>
<p><img alt="debugmail-design" src="/media/2014/3/debugmail-design.png" title="DebugMail design" /></p>
<h2>SMTP-сервер</h2>
<p>Необходимо было разработать SMTP-север, который бы не осуществлял доставку письма на целевой хост, а только сохранял его в базе данных. В этом нам отлично помогли модули <a href="https://github.com/andris9/simplesmtp">simplesmtp</a> и <a href="https://github.com/andris9/mailparser">mailparser</a>, которые покрывали все базовые функции необходимые для работы smtp-сервера и парсинга писем. Оставалось только прописать нужные обработчики событий и другой специфичный для задачи код.</p>
<p>В сервисе предполагается, что все письма относятся к определенному проекту. При создании проекта пользователь получает параметры подключения к smtp-серверу среди которых есть пара login-password. На основе этих данных smtp-сервер определяет к какому проекту относится то или иное полученное письмо.</p>
<h2>REST API</h2>
<p>Для взаимодействия клиентского приложения (см. скоро пост про клиентскую часть) с backend было разработано REST API на базе фреймворка <a href="http://expressjs.com/">express</a>. Выбран был именно этот фреймворк из-за его простоты, скорости работы и гибкости. При помощи поддержки middleware, которые пришли из <a href="http://www.senchalabs.org/connect/">connect</a>, можно очень просто встраиваться в процесс обработки запросов. Несколько примеров разработанных middleware:</p>
<ul>
<li>контроль доступа,</li>
<li>content negotiation,</li>
<li>защита от CSRF,</li>
<li>инициализация сессии и тд.</li>
</ul>
<h3>Content negotiation</h3>
<p>Для того, чтобы максимально распараллелить работу с front-end разработчиком, было принято решение реализовывать сервис в виде SPA (single page application) и REST API. Далее возник вопрос, как различать запросы, которые отправляет клиентское приложение, от запросов, которые генерируются браузером автоматически (при загрузке страниц) при том, то URL-адреса REST API и клиентского приложения пересекаются. Самым корректным решением нам показалось использование content negotiation. При поступлении запроса срабатывает middleware, который проверяет какой формат ответа является предпочтительным для клиента, на основании значения из заголовка запроса <code>Accept</code>. Клиентское приложение отправляет значение данного заголовка как <code>application/json</code>, что сообщает серверу о том, что нужно обрабатывать запрос, как запрос к REST API и вернуть результат в виде JSON-документа. Во всех остальных случаях предполагается, что запрос приходит от браузера и происходит рендеринг основного шаблона с подключенным клиентским приложением.</p>
<h3>Маршрутизация</h3>
<p>Изначально было принято решение использовать модуль <a href="https://github.com/visionmedia/express-resource">express-resource</a>, но он оказался недостаточно гибким. Например, нельзя задавать кастомные middleware для определенных маршрутов. <a href="https://github.com/visionmedia/express-resource/pull/66">Pull Request</a> для решения описанной проблемы висит уже больше года, в итоге от <code>express-resource</code> пришлось отказаться в пользу стандартного способа задания маршрутов в express.</p>
<h2>Real-time updates</h2>
<p>Одна из фич сервиса предполагает, что при получении нового письма оно должна сразу появляться в интерфейсе. Для реализации таких real-time обновлений существует несколько популярных решений:</p>
<ul>
<li><a href="http://socket.io">socket.io</a></li>
<li><a href="http://sockjs.org">sockjs</a></li>
<li><a href="http://faye.jcoglan.com/">faye</a></li>
</ul>
<p>Мы остановились на Faye, т.к. он:</p>
<ul>
<li>имеет достаточно удобное и простое API,</li>
<li>из коробки поддерживаются server-side clients, что важно, т.к. сообщения генерируются из SMTP-сервера,</li>
<li>достаточно активно разрабатывается.</li>
</ul>
<h3>Аутентификация пользователей</h3>
<p>Основной сложностью было реализовать аутентификацию клиентов, т.к. сессии, которые используются в основном приложении и REST API, здесь не доступны. Для решения этой проблемы была введена аутентификация при подписке на обновления проекта. Предпологается, что при инициализации подписки на уведомления клиент передает <code>user id</code>, <code>session id</code> и <code>token</code>. <code>token</code> является результатом выполнения хэш-функции к параметрам <code>user id</code>, <code>session id</code> и некоторого закрытого ключа. Чтобы реализовать такой механизм отлично подходят, т.н. <a href="http://faye.jcoglan.com/browser/extensions.html">extensions</a>, которые позволяют перехватывать сообщения и выполнять дополнительные действия (проверки, дополнительную обработку данных и тд.). В итоге получается примерно такой код:</p>
<div class="highlight"><pre><span class="nx">client</span><span class="p">.</span><span class="nx">addExtension</span><span class="p">({</span>
  <span class="nx">outgoing</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">channel</span> <span class="o">!==</span> <span class="s1">&#39;/meta/subscribe&#39;</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>

    <span class="nx">message</span><span class="p">.</span><span class="nx">ext</span> <span class="o">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">ext</span> <span class="o">||</span> <span class="p">{};</span>
    <span class="nx">message</span><span class="p">.</span><span class="nx">ext</span><span class="p">.</span><span class="nx">uid</span> <span class="o">=</span> <span class="nx">USER_ID</span><span class="p">;</span>
    <span class="nx">message</span><span class="p">.</span><span class="nx">ext</span><span class="p">.</span><span class="nx">sid</span> <span class="o">=</span> <span class="nx">SESSION_ID</span><span class="p">;</span>
    <span class="nx">message</span><span class="p">.</span><span class="nx">ext</span><span class="p">.</span><span class="nx">token</span> <span class="o">=</span> <span class="nx">PRIVATE_TOKEN</span><span class="p">;</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>


<p>Аналогичная система расширений на стороне сервера позволяет выполнять проверку и разрешать подписываться на обновления по проектам только тем пользователям, которые действительно имеют к ним доступ.</p>
<h2>Автоматическое тестирование</h2>
<p>Зачем нужно писать тесты я думаю объяснять не нужно. В данном проекте мы хотели добиться максимального покрытия кода тестами. Для этого практически весь код тестируется сразу на 2х уровнях, на функциональном и на модульном.</p>
<p>Писать тесты на node.js - одно удовольствие. В основном это так благодаря большому количеству удобных инструментов и модулей в <a href="https://npmjs.org/">npm</a>. Также помогают особенностям javascript и node.js, которые предоставляют все необходимые возможности для удобного создания <a href="http://en.wikipedia.org/wiki/Mock_object">моков</a>. Рассмотрим, какие модули использовались и с какой целью:</p>
<ul>
<li><a href="http://visionmedia.github.io/mocha/">mocha</a> - многофункциональный тестовый фреймворк, содержит все необходимые функции для структурирования, поиска, запуска, подсчета метрик, просмотра результатов выполнения тестов и тд. Поддерживает как синхронные так и асинхронные тесты и имеет широкие возможности для кастомизации процесса тестирования.</li>
<li><a href="https://github.com/visionmedia/supertest">supertest</a> - модуль для выполнения функционального тестирования. Все что нужно для начала работы с supertest - передать ему экземпляр приложения express, после этого можно выполнять запросы к приложению и тестировать полученные ответы. Также supertest предоставляет удобный chaining api, типичный тест выглядит так:</li>
</ul>
<div class="highlight"><pre><span class="nx">request</span><span class="p">(</span><span class="nx">app</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/user&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;Accept&#39;</span><span class="p">,</span> <span class="s1">&#39;application/json&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">expect</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nx">done</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>

    <span class="c1">// ... check something here ...</span>

    <span class="nx">done</span><span class="p">()</span>
  <span class="p">});</span>
</pre></div>


<ul>
<li><a href="https://github.com/visionmedia/should.js/">should.js</a> - это библиотека для удобного выполнения assertions. При инициализации библиотека перегружает встроенные объекты javascript, что позволяет использовать красивые конструкции вроде <code>user.should.have.property('company', 'wbtech')</code>. Предоставляет большое количество полезных фич, что делает написание тестов более приятным и быстрым процессом.</li>
<li><a href="https://github.com/felixge/node-sandboxed-module">sandboxed-module</a> - модуль для <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>. Позволяет загрузить модуль с подменой указанных модулей, а также локальных и глобальных переменных.</li>
<li><a href="https://github.com/pgte/nock">nock</a> - позволяет перехватывать запросы, которые делает код, через http протокол. Можно переопределять все запросы или по определенным признакам (например, url запроса, заголовки или тело запроса) и задавать ответ, который будет возвращаться в вызываемый код. Есть много дополнительных плюшек, вроде задания задержек, chaining api и тд.</li>
</ul>
<p>Стоит отметить, что тесты выполняются очень быстро. На данный момент 320 тестов выполняются примерно за 17с (в один поток).</p>
<h2>Некоторые используемые модули</h2>
<p>Список некоторых полезных модулей, о которых не упоминал выше:</p>
<ul>
<li><a href="https://github.com/caolan/async">async</a>, <a href="http://lodash.com/">lodash</a> - незаменимые модули, полезны практически в каждом проекте.<ul>
<li>async предоставляет очень простой способ для выполнения асинхронного кода.</li>
<li>lodash модуль для упрощения работы с различными структурами данных, также содержит методы для упрощения функционального программирования и <a href="http://lodash.com/docs">многое другое</a>.</li>
</ul>
</li>
<li><a href="http://ectjs.com/">ect</a> - очень быстрый и в тоже время гибкий шаблонизатор, который работает с синтаксисом CoffeeScript.</li>
<li><a href="http://www.nodemailer.com/">nodemailer</a> - для отправки писем, есть все что нужно, кастомизируется.</li>
<li><a href="http://passportjs.org/">passport</a> - все что нужно для аутентификации через сторонние ресурсы. Поддерживает <a href="https://github.com/jaredhanson/passport/wiki/Strategies#providers">множество провайдеров</a> через сторонние модули.</li>
<li><a href="https://github.com/mattrobenolt/raven-node">raven-node</a> - node.js клент к <a href="https://getsentry.com/">Sentry</a>.</li>
</ul><p><a href="/nodejs/servernaia-arkhitektura-debugmail/#disqus_thread">comments</a></p>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Остальные статьи</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/ispolzuem-sessiiu-express-v-socketio/" rel="bookmark"
                           title="Permalink to Используем сессию express в socket.io">Используем сессию express в socket.io</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-04-19T13:33:00+04:00">
                пт 19 апреля 2013
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/nodejs.html">node.js</a><a href="/tag/express.html">express</a><a href="/tag/socketio.html">socket.io</a></p>
</footer><!-- /.post-info -->                <p>При разработке приложения с использованием socket.io + express часто возникает задача использования сессии express в socket.io. Рассмотрим, как можно решить эту задачу.</p>
<h2>Используемые пакеты</h2>
<p>Нам нужно установить несколько пакетов, которые пригодятся для решения поставленной задачи (предполагается что express и soket.io уже установлены):</p>
<div class="highlight"><pre>npm install cookie express-session-mongo
</pre></div>


<ul>
<li><code>cookie</code> - модуль ...</li></ul>
                <a class="readmore" href="/nodejs/ispolzuem-sessiiu-express-v-socketio/">читать дальше</a>
<p><a href="/nodejs/ispolzuem-sessiiu-express-v-socketio/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/masshtabirovanie-nodejs-prilozhenii/" rel="bookmark"
                           title="Permalink to Масштабирование Node.js приложений">Масштабирование Node.js приложений</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-02-17T01:17:00+04:00">
                вс 17 февраля 2013
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/cluster/">cluster</a><a href="/tag/load-balancing/">load balancing</a><a href="/tag/clustering/">clustering</a><a href="/tag/scaling/">scaling</a></p>
</footer><!-- /.post-info -->                <p>Все мы знаем, что node.js так популярен благодаря своей производительности. Он работает быстро благодаря разным факторам, таким как использование движка Google V8 и асинхронному i/o. Именно такая высокая производительность позволяет достаточно долго не задумываться о масштабировании приложения, т.к. даже один запущенный Node.js процесс может обслуживать сотни ...</p>
                <a class="readmore" href="/nodejs/masshtabirovanie-nodejs-prilozhenii/">читать дальше</a>
<p><a href="/nodejs/masshtabirovanie-nodejs-prilozhenii/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/coffeescript-nodejs-dev-server/" rel="bookmark"
                           title="Permalink to CoffeeScript & node.js dev-сервер">CoffeeScript & node.js dev-сервер</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-01-19T22:10:00+04:00">
                сб 19 января 2013
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/coffeescript.html">coffeescript</a><a href="/tag/forever.html">forever</a><a href="/tag/nodejs.html">node.js</a></p>
</footer><!-- /.post-info -->                <p>CoffeeScript - язык программирования, компилируемый в javascript. Используя <a href="http://coffeescript.org/">CoffeeScript</a> для разработки на <a href="/tag/nodejs/">node.js</a> мы можем избавиться от некоторых, не очень приятных, особенностей javascript.
<img alt="node.js and coffee-script" src="media/2013/01/nodejs-and-coffeescript.png" title="node.js and coffee-script" />
Сегодня мы рассмотрим, как автоматизировать процесс компиляции CoffeeScript в javascript. Также настроим автоматическую перезагрузку приложения, после каждой новой компиляции.</p>
<h1>Устанавливаем пакеты</h1>
<p>Для выполнения нашей цели необходимо установить ...</p>
                <a class="readmore" href="/nodejs/coffeescript-nodejs-dev-server/">читать дальше</a>
<p><a href="/nodejs/coffeescript-nodejs-dev-server/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/ispolzuem-npm-dlia-upravleniia-zavisimostiami/" rel="bookmark"
                           title="Permalink to Используем npm для управления зависимостями">Используем npm для управления зависимостями</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-01-04T20:10:00+04:00">
                пт 04 января 2013
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/npm.html">npm</a><a href="/tag/packagejson.html">package.json</a></p>
</footer><!-- /.post-info -->                <p>npm - пакетный менеджер для <a href="/tag/nodejs/" title="Node.js">node.js</a>. Сегодня мы рассмотрим как использовать npm для управления зависимостями и автоматизации деплоймента.</p>
<p><img alt="npm package management" src="media/2013/01/npm.png" title="node packaged modules" /></p>
<h1>Установка npm</h1>
<p>Если у вас не установлен <code>npm</code>, то сделать это можно выполнив следующую команду:</p>
<div class="highlight"><pre>curl https://npmjs.org/install.sh <span class="p">|</span> sh
</pre></div>


<h1>Установка пакетов</h1>
<p>Для того чтобы установить пакет при помощи <code>npm ...</code></p>
                <a class="readmore" href="/nodejs/ispolzuem-npm-dlia-upravleniia-zavisimostiami/">читать дальше</a>
<p><a href="/nodejs/ispolzuem-npm-dlia-upravleniia-zavisimostiami/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/nasledovanie-svoistv-modelei-v-mongoose/" rel="bookmark"
                           title="Permalink to Наследование свойств моделей в Mongoose">Наследование свойств моделей в Mongoose</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-01-02T02:41:00+04:00">
                ср 02 января 2013
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/mongoose.html">mongoose</a><a href="/tag/mongodb.html">mongodb</a><a href="/tag/nodejs.html">node.js</a><a href="/tag/sugarjs.html">sugar.js</a></p>
</footer><!-- /.post-info -->                <p>Всех с прошедшим Новым Годом! Сегодня я покажу как наследовать свойства
моделей в <a href="http://mongoosejs.com/" title="Mongoose ODM">ODM Mongoose</a>. Для тех, кто не знает mongoose - это 
ODM (object document mapper) для node.js и <a href="http://www.mongodb.org/" title="MongoDB">MongoDB</a>. </p>
<h2>Применение</h2>
<p>Часто бывает необходимо в рамках одной коллекции объектов выделить несколько
типов с некоторыми различиями в наборе свойств. Т ...</p>
                <a class="readmore" href="/nodejs/nasledovanie-svoistv-modelei-v-mongoose/">читать дальше</a>
<p><a href="/nodejs/nasledovanie-svoistv-modelei-v-mongoose/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/" rel="bookmark"
                           title="Permalink to Очередь сообщений на node.js и memcacheq">Очередь сообщений на node.js и memcacheq</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2011-10-07T23:24:00+04:00">
                пт 07 октября 2011
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/memcacheq/">memcacheq</a><a href="/tag/nodejs/">node.js</a><a href="/tag/php/">PHP</a><a href="/tag/ochered-soobshchenii/">очередь сообщений</a></p>
</footer><!-- /.post-info -->                <p>Привет! Столкнулся с необходимостью использования очередей сообщений в
текущем проекте. Знаю что есть готовые решения, но я все же решил
написать свой небольшой велосипед. Итак, поехали...</p>
<h2>Описание</h2>
<p><img alt="scheme" src="/media/2011/10/png" /></p>
<p>В поставленной передо мной задаче необходимо выполнять ресурсоемкие
операции (такие как работа с сетью, декодирование mp3-файлов), а также
обращаться к бизнес-логике приложения для ...</p>
                <a class="readmore" href="/nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/">читать дальше</a>
<p><a href="/nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/khranilishcha-dannykh-v-nodejs-memcachedb/" rel="bookmark"
                           title="Permalink to Хранилища данных в Node.JS. Memcachedb">Хранилища данных в Node.JS. Memcachedb</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2011-07-02T23:04:00+04:00">
                сб 02 июля 2011
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/memcachedb/">memcachedb</a><a href="/tag/nodejs/">node.js</a></p>
</footer><!-- /.post-info -->                <p><img alt="MemcacheDB" src="/media/2011/07/Снимок-300x204.png" /></p>
<p>Сегодня я расскажу, как начать работать с MemcacheDB в Node.JS.</p>
<h2>Memcachedb</h2>
<p>Memcachedb - это key-value база данных, основанная на memcached. Для
тех, кто работал с memcached, начало работы с memcachedb не будет
требовать особых усилий, т.к. они используют общее API. Основные
возможности Memcachedb:</p>
<ul>
<li>Распределенное хранилище пар ключ-значение</li>
<li>В отличие ...</li></ul>
                <a class="readmore" href="/nodejs/khranilishcha-dannykh-v-nodejs-memcachedb/">читать дальше</a>
<p><a href="/nodejs/khranilishcha-dannykh-v-nodejs-memcachedb/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/web-chat-polling-na-nodejs/" rel="bookmark"
                           title="Permalink to Web-чат polling на Node.JS">Web-чат polling на Node.JS</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2011-04-10T21:49:00+04:00">
                вс 10 апреля 2011
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/cross-domain-ajax/">cross domain ajax</a><a href="/tag/java-script/">java script</a><a href="/tag/jquery/">jquery</a><a href="/tag/nodejs/">node.js</a><a href="/tag/polling/">polling</a></p>
</footer><!-- /.post-info -->                <p><img alt="чат" src="/media/2011/04/conversacion-150x150.png" title="чат" /></p>
<p>Продолжим тему создания чата на Node.JS. На этот раз напишем чат,
который будет в качестве клиентов использовать браузеры.</p>
<h2>Проблема</h2>
<p>Т.к. протокол HTTP не позволяет устанавливать постоянное соединение
сервера с клиентом, то нам необходимо самостоятельно инициировать
соединение для считывания новых сообщений. Для этого существует
множество способов, но мы для ...</p>
                <a class="readmore" href="/nodejs/web-chat-polling-na-nodejs/">читать дальше</a>
<p><a href="/nodejs/web-chat-polling-na-nodejs/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
        

 
            <li><article class="hentry">    
                <header>
                    <h1><a href="/nodejs/nodejs-mysql/" rel="bookmark"
                           title="Permalink to Node.JS + MySQL">Node.JS + MySQL</a></h1>
                </header>
                
                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2011-03-28T18:47:00+04:00">
                пн 28 марта 2011
        </abbr>
<p>категория: <a href="/category/nodejs.html">Node.js</a>. </p>
<p>теги: <a href="/tag/mysql/">MySQL</a><a href="/tag/node-mysql/">node-mysql</a><a href="/tag/nodejs/">node.js</a></p>
</footer><!-- /.post-info -->                <p><img alt="Mysql + Node.js" src="/media/2011/03/Mysql-300x76.png" title="Mysql + Node.js" /></p>
<p>В последнем проекте появилась необходимость
организации работы Node.JS с MySQL. Для создания данного взаимодействия
существует несколько модулей, я решил использовать <strong>node-mysql</strong>, т.к.
он предоставляет все необходимые мне функции.</p>
<h2>Установка node-mysql</h2>
<p>Для установки воспользуемся git:</p>
<div class="highlight"><pre><span class="nb">cd</span> ~/.node_libraries
git clone git://github.com/felixge/node-mysql.git mysql
</pre></div>


<p>После этого вы ...</p>
                <a class="readmore" href="/nodejs/nodejs-mysql/">читать дальше</a>
<p><a href="/nodejs/nodejs-mysql/#disqus_thread">comments</a></p>                </div><!-- /.entry-content -->
            </article></li>
            </ol><!-- /#posts-list -->
<p class="paginator">
    Страница 1 / 2
        <a href="/category/nodejs2.html">&raquo;</a>
</p>
            </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>ссылки</h2>
                        <ul>
                            <li><a href="http://wbtech.pro">WBTech</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>онлайн</h2>
                        <ul>
                            <li><a href="http://dizballanze.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="http://dizballanze.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                            <li><a href="https://twitter.com/dizballanze">Twitter</a></li>
                            <li><a href="https://github.com/dizballanze">GitHub</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Powered by <a href="http://getpelican.com/">Pelican</a>, <a href="http://python.org">Python</a>.
                <section class="right">&copy; <a href="/avtor">Yuri Shikanov</a> 2010-2015</section>
                </address><!-- /#about -->

        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-20497524-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'dizballanze';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>