<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="HandheldFriendly" content="true">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Django project optimization guide (part 2)</title>
    <link rel="stylesheet" href="/theme/css/native.css" />
    <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif&amp;subset=cyrillic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=PT+Mono&amp;subset=cyrillic" rel="stylesheet">
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-20497524-1', 'auto');
      ga('send', 'pageview');
    </script>
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
  styles: {
  ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
  },
  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']],processEscapes: true}
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body id="index" class="home">
        <header id="banner" class="body">
            <h1><a href="/en/">Tech blog by @dizballanze <strong></strong></a></h1>
            <div id="langs">
                <a href="/">En</a>
                <a href="/ru/">Ru</a>
            </div>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/en/about-me/">Author</a></li>
            <li><a href="https://wbtech.pro/">WBâ€“Tech</a></li>
            <li><a href="https://debugmail.io/">DebugMail</a></li>
        </ul>
        </nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/en/django-project-optimization-part-2/" rel="bookmark"
         title="Permalink to Django project optimization guide (part 2)">Django project optimization guide (part 2)</a></h2>
    <time class="published" datetime="2017-06-29T17:02:00+03:00"><nobr>29 Jun 2017</nobr></time>
  </header>
  <div class="entry-content">
    <p>Table of Contents:</p>
<ul>
<li><a href="#mass-edit">Mass edit</a><ul>
<li><a href="#mass-insertion">Mass insertion</a></li>
<li><a href="#mass-m2m-insertion">Mass M2M insertion</a></li>
<li><a href="#mass-update">Mass update</a></li>
<li><a href="#mass-delete">Mass delete</a></li>
</ul>
</li>
<li><a href="#iterator_1">Iterator</a></li>
<li><a href="#foreign-keys">Foreign keys</a></li>
<li><a href="#retrieving-of-related-objects">Retrieving of related objects</a></li>
<li><a href="#defer-fields-retrieving">Defer fields retrieving</a></li>
<li><a href="#database-indexes">Database indexes</a></li>
<li><a href="#lenqs-vs-qscount">len(qs) vs qs.count</a></li>
<li><a href="#count vs exists">count vs exists</a></li>
<li><a href="#Lazy QuerySet">Lazy QuerySet</a></li>
</ul>
<p>This is the second part of Django project optimization series. The first part was about profiling and Django settings, 
it's available <a href="/django-project-optimization-part-1/">here</a>. This part will be about working
with database optimization (Django models).</p>
<p>We will use SQL logging and Django Debug Toolbar described in the first part of this series. I will use
PostgreSQL in all examples, but most part of this guide will be useful for other databases too.</p>
<p>Examples in this part are based on simple blog application, that we will build and optimize throughout the guide. Let's
begin with the following models:</p>
<p>```python
from django.db import models</p>
<p>class Tag(models.Model):</p>
<pre><code>name = models.CharField(max_length=64)

def __str__(self):
    return self.name
</code></pre>
<p>class Author(models.Model):</p>
<pre><code>username = models.CharField(max_length=64)
email = models.EmailField()
bio = models.TextField()

def __str__(self):
    return self.username
</code></pre>
<p>class Article(models.Model):</p>
<pre><code>title = models.CharField(max_length=64)
content = models.TextField()
created_at = models.DateField()
author = models.ForeignKey(Author)
tags = models.ManyToManyField(Tag)

def __str__(self):
    return self.title
</code></pre>
<p>```</p>
<p>All code is available on <a href="https://github.com/dizballanze/django-optimization-guide-2-sample/tree/initial">GitHub</a>
with <a href="https://github.com/dizballanze/django-optimization-guide-2-sample/tags">tags</a>.</p>
<h2 id="mass-edit">Mass edit</h2>
<h3 id="mass-insertion">Mass insertion</h3>
<p>Let's imagine, that our new blog application replaces some old one and we need to transfer data to new models.
We have exported data from old application to large JSON files. File with authors has following structure:</p>
<p><code>json
[
  {
    "username": "mackchristopher",
    "email": "dcortez@yahoo.com",
    "bio": "Vitae mollitia in modi suscipit similique. Tempore sunt aliquid porro. Molestias tempora quos corporis quam."
  }
]</code></p>
<p>Let's create Django command to import authors from JSON file:</p>
<p>```python
class Command(BaseCommand):</p>
<pre><code>help = 'Load authors from `data/old_authors.json`'

DATA_FILE_PATH = os.path.join(settings.BASE_DIR, '..', 'data', 'old_data.json')

def handle(self, *args, **kwargs):
    with open(self.DATA_FILE_PATH, 'r') as json_file:
        data = json.loads(json_file.read())
    for author in data:
        self._import_author(author)

def _import_author(self, author_data):
    author = Author(
        username=author_data['username'],
        email=author_data['email'],
        bio=author_data['bio'])
    author.save()
</code></pre>
<p>```</p>
<p>Now we will check how many SQL requests performed on importing 200 authors. Run in <code>python manage.py shell</code>:</p>
<p><code>python
from django.core.management import call_command
from django.db import connection
call_command('load_data')
print(len(connection.queries))</code></p>
<p>This code will print a bunch of SQL requests (because SQL logging is enabled) and in the last line, we will see number <code>200</code>
This means, that for every author we perform separated <code>INSERT</code> SQL request. If you have huge amount of data, this
approach could be very slow. Let's use method <code>bulk_create</code> of <code>Author</code> model manager:</p>
<p>```python
    def handle(self, <em>args, </em>*kwargs):
        with open(self.DATA_FILE_PATH, 'r') as json_file:
            data = json.loads(json_file.read())
        author_instances = []
        for author in data:
            author_instances.append(self._import_author(author))
        Author.objects.bulk_create(author_instances)</p>
<pre><code>def _import_author(self, author_data):
    author = Author(
        username=author_data['username'],
        email=author_data['email'],
        bio=author_data['bio'])
    return author
</code></pre>
<p>```</p>
<p>This command generates one huge SQL request for all authors.</p>
<blockquote>
<p>If you have really large amount of data, probably, you will need to break insertion into several SQL requests.
You can use a <code>batch_size</code> argument of the <code>bulk_create</code> method for this.
If we want to insert 200 objects (rows) to a database and provide <code>bulk_size=50</code>, Django will generate 4 requests.</p>
<p>The <code>bulk_size</code> method has several drawbacks, you can read about them in the <a href="https://docs.djangoproject.com/en/1.11/ref/models/querysets/#bulk-create">documentation</a>.</p>
</blockquote>
<h3 id="mass-m2m-insertion">Mass M2M insertion</h3>
<p>Now we need to import articles and tags. They are available in separate JSON file with following structure:</p>
<p><code>json
[
  {
    "created_at": "2016-06-11",
    "author": "nichole52",
    "tags": [
      "ab",
      "iure",
      "iusto"
    ],
    "title": "...",
    "content": "..."
  }
]</code></p>
<p>Let's write another command for this:</p>
<p>```python
class Command(BaseCommand):</p>
<pre><code>help = 'Load articles from `data/old_articles.json`'

DATA_FILE_PATH = os.path.join(settings.BASE_DIR, '..', 'data', 'old_articles.json')

def handle(self, *args, **kwargs):
    with open(self.DATA_FILE_PATH, 'r') as json_file:
        data = json.loads(json_file.read())
    for article in data:
        self._import_article(article)

def _import_article(self, article_data):
    author = Author.objects.get(username=article_data['author'])
    article = Article(
        title=article_data['title'],
        content=article_data['content'],
        created_at=article_data['created_at'],
        author=author)
    article.save()
    for tag in article_data['tags']:
        tag_instance, _ = Tag.objects.get_or_create(name=tag)
        article.tags.add(tag_instance)
</code></pre>
<p>```</p>
<p>After running this command database received 3349 SQL requests! Most of them look like as follows:</p>
<p><code>SQL
(0.001) SELECT "blog_article_tags"."tag_id" FROM "blog_article_tags" WHERE ("blog_article_tags"."article_id" = 2319 AND "blog_article_tags"."tag_id" IN (67)); args=(2319, 67)
(0.000) INSERT INTO "blog_article_tags" ("article_id", "tag_id") VALUES (2319, 67) RETURNING "blog_article_tags"."id"; args=(2319, 67)
(0.000) SELECT "blog_tag"."id", "blog_tag"."name" FROM "blog_tag" WHERE "blog_tag"."name" = 'fugiat'; args=('fugiat',)
(0.001) SELECT "blog_article_tags"."tag_id" FROM "blog_article_tags" WHERE ("blog_article_tags"."article_id" = 2319 AND "blog_article_tags"."tag_id" IN (68)); args=(2319, 68)
(0.000) INSERT INTO "blog_article_tags" ("article_id", "tag_id") VALUES (2319, 68) RETURNING "blog_article_tags"."id"; args=(2319, 68)
(0.000) SELECT "blog_tag"."id", "blog_tag"."name" FROM "blog_tag" WHERE "blog_tag"."name" = 'repellat'; args=('repellat',)
(0.001) SELECT "blog_article_tags"."tag_id" FROM "blog_article_tags" WHERE ("blog_article_tags"."article_id" = 2319 AND "blog_article_tags"."tag_id" IN (58)); args=(2319, 58)
(0.000) INSERT INTO "blog_article_tags" ("article_id", "tag_id") VALUES (2319, 58) RETURNING "blog_article_tags"."id"; args=(2319, 58</code></p>
<p>Adding each tag to the article is performed with separated request. We can improve this command by invoking <code>article.tags.add</code>
method with all tags for a current article:</p>
<p><code>python
    def _import_article(self, article_data):
        # ...
        tags = []
        for tag in article_data['tags']:
            tag_instance, _ = Tag.objects.get_or_create(name=tag)
            tags.append(tag_instance)
        article.tags.add(*tags)</code></p>
<p>This version sends only 1834 requests, almost 2 times fewer.</p>
<h3 id="mass-update">Mass update</h3>
<p>After data import, we decided, that we need to disallow commenting on old articles (created before 2012). I added
the <code>comments_on</code> boolean field to the <code>Article</code> model. Now, we need to set its values:</p>
<p><code>python
from django.db import connection
from blog.models import Article
for article in Article.objects.filter(created_at__year__lt=2012):
    article.comments_on = False
    article.save()
print(len(connection.queries))</code></p>
<p>This code generates 179 requests like following:</p>
<p><code>sql
(0.000) UPDATE "blog_article" SET "title" = 'Saepe eius facere magni et eligendi minima sint.', "content" = '...', "created_at" = '1992-03-01'::date, "author_id" = 730, "comments_on" = false WHERE "blog_article"."id" = 3507; args=('Saepe eius facere magni et eligendi minima sint.', '...', datetime.date(1992, 3, 1), 730, False, 3507)</code></p>
<p>This code generates an individual request for each article older than 2012. Moreover, this code rewrites all fields of the article. This can overwrite changes made between SELECT and UPDATE requests, that means that we not only get the performance issue, but also we get the race condition.</p>
<p>Instead, we can use <code>update</code> method of <code>QuerySet</code> instance:</p>
<p><code>python
Article.objects.filter(created_at__year__lt=2012).update(comments_on=False)</code></p>
<p>This code generates just one SQL request:</p>
<p><code>sql
(0.004) UPDATE "blog_article" SET "comments_on" = false WHERE "blog_article"."created_at" &lt; '2012-01-01'::date; args=(False, datetime.date(2012, 1, 1))</code></p>
<p>If field update requires complex logic, that can't be performed by single <code>UPDATE</code> request, you can compute field values
via Python code and then use one of the following option:</p>
<p>```python
Model.object.filter(id=instance.id).update(field=computed_value)</p>
<h1 id="or_2">or</h1>
<p>instance.field = computed_value
instance.save(update_fields=('fields',))
```</p>
<p>But this options also suffers from race conditions.</p>
<h3 id="mass-delete">Mass delete</h3>
<p>Now, we need to remove all articles with tag <code>minus</code>:</p>
<p><code>python
from django.db import connection
from blog.models import Article
for article in Article.objects.filter(tags__name='minus'):
    article.delete()
print(len(connection.queries))</code></p>
<p>This code generates 93 requests as follows:</p>
<p><code>sql
(0.000) DELETE FROM "blog_article_tags" WHERE "blog_article_tags"."article_id" IN (3510); args=(3510,)
(0.000) DELETE FROM "blog_article" WHERE "blog_article"."id" IN (3510); args=(3510,)</code></p>
<p>At first, this code removes the connection between article and tag. After that, the article itself is deleted. We can perform
this in less amount of <code>requests</code> with <code>delete</code> method of <code>QuerySet</code> instance:</p>
<p><code>python
from django.db import connection
from blog.models import Article
Article.objects.filter(tags__name='minus').delete()
print(len(connection.queries))</code></p>
<p>This code perform the same but only with 3 requests to the database:</p>
<p><code>sql
(0.004) SELECT "blog_article"."id", "blog_article"."title", "blog_article"."content", "blog_article"."created_at", "blog_article"."author_id", "blog_article"."comments_on" FROM "blog_article" INNER JOIN "blog_article_tags" ON ("blog_article"."id" = "blog_article_tags"."article_id") INNER JOIN "blog_tag" ON ("blog_article_tags"."tag_id" = "blog_tag"."id") WHERE "blog_tag"."name" = 'minus'; args=('minus',)
(0.002) DELETE FROM "blog_article_tags" WHERE "blog_article_tags"."article_id" IN (3713, 3717, 3722, ...); args=(3713, 3717, 3722, ...)
(0.001) DELETE FROM "blog_article" WHERE "blog_article"."id" IN (3713, 3717, ...); args=(3713, 3717, 3722, ...)``sql</code></p>
<p>At first, ids of all articles, marked with <code>minus</code> tag, are selected. Then the second request removes all connections
between this articles and tags. At last the articles itself are deleted.</p>
<h2 id="iterator_1">Iterator</h2>
<p>Let's pretend that we need to export articles to CSV file. This is the command to perform export:</p>
<p>```python
class Command(BaseCommand):</p>
<pre><code>help = 'Export articles to csv'

EXPORT_FILE_PATH = os.path.join(settings.BASE_DIR, '..', 'data', 'articles_export.csv')
COLUMNS = ['title', 'content', 'created_at', 'author', 'comments_on']

def handle(self, *args, **kwargs):
    with open(self.EXPORT_FILE_PATH, 'w') as export_file:
        articles_writer = csv.writer(export_file, delimiter=';')
        articles_writer.writerow(self.COLUMNS)
        for article in Article.objects.select_related('author').all():
            articles_writer.writerow([getattr(article, column) for column in self.COLUMNS])
</code></pre>
<p>```</p>
<p>For testing purpose, I generated around 100Mb of articles and loaded them to DB. After that, I ran CSV export command with
<a href="https://pypi.python.org/pypi/memory_profiler">memory profiler</a>.</p>
<p><code>mprof run python manage.py export_articles
mprof plot</code></p>
<p>As a result, I received the following graph of memory consumption:</p>
<p><img alt="export articles profiling" src="/media/2017/6/export_articles_without_iterator.png"/></p>
<p>Command utilizes ~250Mb of memory because <code>QuerySet</code> receives all articles from DB at once and caches them to the memory
in order to use it in the next accesses to <code>QuerySet</code>. You can reduce memory consumption through use of <code>iterator</code> method.
This method allows to get query results one by one (with the <a href="http://initd.org/psycopg/docs/cursor.html">server-side cursor</a>)
and also it disables caching.</p>
<p>```python</p>
<h1 id="_2">...</h1>
<p>for article in Article.objects.select_related('author').iterator():</p>
<h1 id="_3">...</h1>
<p>```</p>
<p>This is the result of running the updated command in the memory profiler:</p>
<p><img alt="export articles profiling" src="/media/2017/6/export_articles_with_iterator.png"/></p>
<p>Now the command utilizes only 50Mb of memory. Also, the pleasant side-effect is that memory utilization almost constant
for any amount of articles. Those are results for ~200Mb of articles (without and with the <code>iterator</code>):</p>
<p><img alt="huge export articles profiling" src="/media/2017/6/export_articles_huge_before_and_after.png"/></p>
<h2 id="foreign-keys">Foreign keys</h2>
<p>Now we have to add Django admin action to make a copy of the article: </p>
<p><code>python
def clone_article(modeladmin, request, queryset):
    if queryset.count() != 1:
        modeladmin.message_user(request, "You could clone only one article at a time.", level=messages.ERROR)
        return
    origin_article = queryset.first()
    cloned_article = Article(
        title="{} (COPY)".format(origin_article.title),
        content=origin_article.content,
        created_at=origin_article.created_at,
        author=origin_article.author,
        comments_on=origin_article.comments_on)
    cloned_article.save()
    cloned_article.tags = origin_article.tags.all()
    modeladmin.message_user(request, "Article successfully cloned", level=messages.SUCCESS)
clone_article.short_description = 'Clone article'</code></p>
<p>SQL logs:</p>
<p><code>sql
(0.001) SELECT COUNT(*) AS "__count" FROM "blog_article" WHERE "blog_article"."id" IN (31582); args=(31582,)
(0.001) SELECT "blog_article"."id", "blog_article"."title", "blog_article"."content", "blog_article"."created_at", "blog_article"."author_id", "blog_article"."comments_on" FROM "blog_article" WHERE "blog_article"."id" IN (31582) ORDER BY "blog_article"."created_at" DESC, "blog_article"."id" DESC LIMIT 1; args=(31582,)
(0.000) SELECT "blog_author"."id", "blog_author"."username", "blog_author"."email", "blog_author"."bio" FROM "blog_author" WHERE "blog_author"."id" = 2156; args=(2156,)
(0.001) INSERT INTO "blog_article" ("title", "content", "created_at", "author_id", "comments_on") VALUES ('Explicabo maiores nobis cum vel fugit. (COPY)', ...</code></p>
<p>For some reason, author's data is also fetched from DB, but we don't need any information about author besides his/her id
(that already is in the article as a foreign key). To fix this you need to refer directly to a foreign key through
<code>origin_article.author_id</code>. I rewrote cloned object population as follows:</p>
<p><code>python
cloned_article = Article(
    title="{} (COPY)".format(origin_article.title),
    content=origin_article.content,
    created_at=origin_article.created_at,
    author_id=origin_article.author_id,
    comments_on=origin_article.comments_on)</code></p>
<p>And there is no author related request in logs.</p>
<h2 id="retrieving-of-related-objects">Retrieving of related objects</h2>
<p>It's time to make our articles public. I will begin with simple articles list page. Let's build view:</p>
<p>```python
class ArticlesListView(ListView):</p>
<pre><code>template_name = 'blog/articles_list.html'
model = Article
context_object_name = 'articles'
paginate_by = 20
</code></pre>
<p>```</p>
<p>There is information about an article, author and tags in the template:</p>
<p><code>django
&lt;article&gt;
    &lt;h2&gt;{{ article.title }}&lt;/h2&gt;
    &lt;time&gt;{{ article.created_at }}&lt;/time&gt;
    &lt;p&gt;Author: {{ article.author.username }}&lt;/p&gt;
    &lt;p&gt;Tags:
    {% for tag in article.tags.all %}
        {{ tag }}{% if not forloop.last %}, {% endif %}
    {% endfor %}
&lt;/article&gt;</code></p>
<p>DDT shows us that this page generates 45 SQL request as follows:</p>
<p><code>sql
(0.002) SELECT "blog_article"."id", "blog_article"."title", "blog_article"."content", "blog_article"."created_at", "blog_article"."author_id", "blog_article"."comments_on" FROM "blog_article" LIMIT 20; args=()
(0.001) SELECT "blog_author"."id", "blog_author"."username", "blog_author"."email", "blog_author"."bio" FROM "blog_author" WHERE "blog_author"."id" = 2043; args=(2043,)
(0.001) SELECT "blog_tag"."id", "blog_tag"."name" FROM "blog_tag" INNER JOIN "blog_article_tags" ON ("blog_tag"."id" = "blog_article_tags"."tag_id") WHERE "blog_article_tags"."article_id" = 20425; args=(20425,)
(0.000) SELECT "blog_author"."id", "blog_author"."username", "blog_author"."email", "blog_author"."bio" FROM "blog_author" WHERE "blog_author"."id" = 2043; args=(2043,)
(0.001) SELECT "blog_tag"."id", "blog_tag"."name" FROM "blog_tag" INNER JOIN "blog_article_tags" ON ("blog_tag"."id" = "blog_article_tags"."tag_id") WHERE "blog_article_tags"."article_id" = 20426; args=(20426,)</code></p>
<p>Primarily we receive all articles (with considering of pagination). Then authors and tags are obtained for each article apart.
Our goal is to make Django get all this related data in minimum possible amount of database requests.</p>
<p>Let's begin with authors. To make <code>QuerySet</code> retrieve related data by foreign keys we need to use the <code>select_related</code> method. I updated the <code>queryset</code> in view as follows:</p>
<p><code>python
queryset = Article.objects.select_related('author')</code></p>
<p>After that DDT shows us that the amount of SQL requests is reduced to 25. That happens because data about articles and
authors data is fetched now by a single <code>JOIN</code> SQL request:</p>
<p><code>sql
(0.004) SELECT "blog_article"."id", "blog_article"."title", "blog_article"."content", "blog_article"."created_at", "blog_article"."author_id", "blog_article"."comments_on", "blog_author"."id", "blog_author"."username", "blog_author"."email", "blog_author"."bio" FROM "blog_article" INNER JOIN "blog_author" ON ("blog_article"."author_id" = "blog_author"."id") LIMIT 21; args=()</code></p>
<p>The <code>select_realted</code> method works only with foreign keys in the current model. To reduce an amount of requests while fetching
multiple related objects (like tags in our example), we need to use the <code>prefetch_related</code> method. The updated <code>queryset</code>
looks like this:</p>
<p><code>python
queryset = Article.objects.select_related('author').prefetch_related('tags')</code></p>
<p>Now DDT shows only 7 requests. Only 2 of them are responsible for displaying articles list:</p>
<p><code>sql
(0.002) SELECT "blog_article"."id", "blog_article"."title", "blog_article"."content", "blog_article"."created_at", "blog_article"."author_id", "blog_article"."comments_on", "blog_author"."id", "blog_author"."username", "blog_author"."email", "blog_author"."bio" FROM "blog_article" INNER JOIN "blog_author" ON ("blog_article"."author_id" = "blog_author"."id") LIMIT 20; args=()
(0.001) SELECT ("blog_article_tags"."article_id") AS "_prefetch_related_val_article_id", "blog_tag"."id", "blog_tag"."name" FROM "blog_tag" INNER JOIN "blog_article_tags" ON ("blog_tag"."id" = "blog_article_tags"."tag_id") WHERE "blog_article_tags"."article_id" IN (16352, 16353, 16354, 16355, 16356, 16357, 16358, 16359, 16360, 16361, 16362, 16363, 16344, 16345, 16346, 16347, 16348, 16349, 16350, 16351); args=(16352, 16353, 16354, 16355, 16356, 16357, 16358, 16359, 16360, 16361, 16362, 16363, 16344, 16345, 16346, 16347, 16348, 16349, 16350, 16351)</code></p>
<blockquote>
<p>You must use <code>select_related</code> to retrieve objects by a foreign key in the current model. To retrieve M2M objects
and objects from other models that refer to the current one you should use <code>prefetch_related</code>.</p>
<p>Also, you can use <code>prefetch_related</code> to fetch related objects of arbitrary nesting levels.</p>
<p><code>Tag.objects.all().prefetch_related('article_set__author')</code></p>
<p>This code will fetch all articles and corresponding authors with tag.</p>
</blockquote>
<h2 id="defer-fields-retrieving">Defer fields retrieving</h2>
<p>If you look closer to the previous example you can see that we retrieve more fields than we needed.
This is the result of the request in DDT:</p>
<p><img alt="SQL query result for articles list" src="/media/2017/6/sql-queries-results.png"/></p>
<p>This SQL request retrieves all fields of article and author, including a potentially huge text of an article. You can
significantly reduce an amount of transferring data with <code>defer</code> method. This method defers retrieving of given fields.
In case of some code tries to access deferred field it will be retrieved in separate SQL request on-demand. Let's add
<code>defer</code> invocation to the <code>queryset</code>:</p>
<p><code>python
queryset = Article.objects.select_related('author').prefetch_related('tags').defer('content', 'comments_on')</code></p>
<p>Now Django don't retrieve unneeded fields and this reduces the time of request processing (before and after <code>defer</code>):</p>
<p><img alt="DDT - SQL speedup after defer" src="/media/2017/6/sql-speedup-defer.png"/></p>
<p>But this request still fetches more data than we need. We receive all author fields. It would be easier to give a list
of fields that we actually need.  We can use 'only' method to define required fields, other fields will be deferred:</p>
<p><code>python
queryset = Article.objects.select_related('author').prefetch_related('tags').only(
    'title', 'created_at', 'author__username', 'tags__name')</code></p>
<p>As a result, we receive only data we need:</p>
<p><img alt="DDT - SQL after only" src="/media/2017/6/sql-after-only.png"/></p>
<p><code>defer</code> and <code>only</code> perform the same task - limiting fetched fields in requests. Differences between this methods are:</p>
<ul>
<li><code>defer</code> defers only specified fields,</li>
<li><code>only</code> defers all fields except specified.</li>
</ul>
<h2 id="database-indexes">Database indexes</h2>
<p>Now we decided to create an author page, that should be accessible by URL like this: <code>/authors/&lt;username&gt;</code>.</p>
<p><code>python
def author_page_view(request, username):
    author = get_object_or_404(Author, username=username)
    return render(request, 'blog/author.html', context=dict(author=author))</code></p>
<p>This code works pretty fast on a small amount of data. But if an amount of data is big and continues to grow, performance
inevitably falls. That's because DBMS has to scan the entire table to find a row by <code>username</code> field. A better
approach is to use database indexes. They allow DBMS to search data much faster. For adding an index to the field you should
add the <code>db_index=True</code> argument to the corresponding model field. After that, you should make and execute the migration.</p>
<p>```python
class Author(models.Model):</p>
<pre><code>username = models.CharField(max_length=64, db_index=True)
# ...
</code></pre>
<p>```</p>
<p>Let's compare the performance before and after we added the index on a database that contains 100K of authors:</p>
<p>Without index:</p>
<p><img alt="select by username without index" src="/media/2017/6/ddt-select-by-username-without-index.png"/></p>
<p>With index:</p>
<p><img alt="select by username with index" src="/media/2017/6/ddt-select-by-username-with-index.png"/></p>
<p>The request is 16x times faster now!</p>
<blockquote>
<p>Indexes are useful not only for data filtration. They speed up sortation as well. Also, many of DBMS provide
multi-field indexes to speed up filtration and sorting by several fields. You should read a documentation to your
DBMS for details.</p>
</blockquote>
<h2 id="lenqs-vs-qscount">len(qs) vs qs.count</h2>
<p>For some reason, we decided to display a counter of authors on the articles list page. Let's update the view:</p>
<p>```python
class ArticlesListView(ListView):</p>
<pre><code># ...

def get_context_data(self, **kwargs):
    context = super().get_context_data(**kwargs)
    context['authors_count'] = len(Author.objects.all())
    return context
</code></pre>
<p>```</p>
<p>This code generates following SQL request:</p>
<p><img alt="DDT - len(qs)" src="/media/2017/6/ddt-authors-len-queryset.png"/></p>
<p>On the screenshot, you can see that we fetch all authors from a database. Therefore counting is performed by the Python
code in view. The optimal approach is to retrieve only the number of authors from the database. We can use <code>count</code>
method for this:</p>
<p><code>python
        context['authors_count'] = Author.objects.count()</code></p>
<p>This is a request generated by the updated code:</p>
<p><img alt="DDT - len(qs)" src="/media/2017/6/ddt-authors-count.png"/></p>
<p>Now Django generates a much more optimal request for our task.</p>
<h2 id="count-vs-exists">count vs exists</h2>
<p>We need to display a link to author's articles on the author's page, but only if he has any. One possible solution is to retrieve
a count of articles and compare it if it is more than 0. Like this:</p>
<p><code>python
def author_page_view(request, username):
    author = get_object_or_404(Author, username=username)
    show_articles_link = (author.articles.count() &gt; 0)
    return render(
        request, 'blog/author.html',
        context=dict(author=author, show_articles_link=show_articles_link))</code></p>
<p>But if we have a huge amount of articles this code will work slowly. Since we don't need to know the exact amount of articles,
we could use <code>exists</code> method, that checks if <code>QuerySet</code> has at least one result.</p>
<p><code>python
    # ...
    show_articles_link = author.articles.exists()
    # ...</code></p>
<p>Let's compare performance on a large amount of articles (~10K):</p>
<p><img alt="DDT - exists vs count" src="/media/2017/6/ddt-exists-vs-count.png"/></p>
<p>So, we reach the goal with requests that 10x faster.</p>
<h2 id="lazy-queryset">Lazy QuerySet</h2>
<p>Now we want the authors to compete each over. For that we will add a rating of top-20 authors by articles count.</p>
<p><code>python
class ArticlesListView(ListView):
    # ...
    def get_context_data(self, **kwargs):
        # ...
        context['top_authors'] = list(
            Author.objects.order_by('-articles_count'))[:20]
        # ...</code></p>
<p>Here we retrieve the list of all authors sorted by articles count and slice first 20 from it. <code>articles</code> count in this
example is a denormalized field with a count of articles of the current user. In a real project, you would probably want
to add signals to update this field on data changes.</p>
<p>I think it's clear that this approach is not ideal. DDT confirms this:</p>
<p><img alt="DDT - get top authors slice" src="/media/2017/6/ddt-top-authors-list.png"/></p>
<p>Of course, we need to receive already truncated list of authors from the database. For that you need to understand that
<code>QuerySet</code> tries to defer hitting the database as far as possible. <code>QuerySet</code> hits database in the following cases:</p>
<ul>
<li>iteration (i.e., <code>for obj in Model.objects.all():</code>),</li>
<li>slicing with specified step (i.e., <code>Model.objects.all()[::2]</code>),</li>
<li>call of <code>len</code> (i.e., <code>len(Model.objects.all())</code>,</li>
<li>call of <code>list</code> (i.e., <code>list(Model.objects.all())</code>,</li>
<li>call of <code>bool</code> (i.e., <code>bool(Model.objects.all())</code>,</li>
<li>serialization with <a href="https://docs.python.org/3/library/pickle.html">pickle</a>.</li>
</ul>
<p>Therefore by calling <code>list</code> we forced <code>QuerySet</code> to hit database and return a list of objects. Slicing was performed
on the list, not on <code>QuerySet</code>. To limit authors in a SQL request we should apply slicing to <code>QuerySet</code> itself:</p>
<p><code>python
context['top_authors'] =\
    Author.objects.order_by('-articles_count')[:20]</code></p>
<p><img alt="DDT - get top authors slice on queryset" src="/media/2017/6/ddt-top-authors-qs-slice.png"/></p>
<p>As you can see, a size of a fetch is limited in the request: <code>...LIMIT 20</code>. Also, DDT shows that <code>QuerySet</code> deferred
hitting the DB until template rendering.</p>
  </div>
</section>
        <footer id="contentinfo" class="body">
            (c) 2010-2017
        </footer><!-- /#contentinfo -->
</body>
</html>