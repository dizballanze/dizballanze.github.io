Title: Практикум Zend Framework. Часть вторая: Route и Registry
Date: 2011-06-12 20:17
Author: Admin
Category: Другое
Tags: registry, route
Lang: ru

![ZendFramework logo][]

Продолжим рассмотрение практического использования Zend Framework. Во
второй части речь пойдет о маршрутизации, что позволит вам создавать
url-адреса любой необходимой для вас формы. Также мы рассмотрим пример
организации удобного доступа к системным константам.

-   [**Часть первая**][]

    -   [**Аутентификация**][] - вход пользователей в систему
    -   [**ACL**][] - распределение прав доступа

-   **Часть вторая**

    -   [**Маршрутизация**][] - настройка url для различных компонентов
        системы
    -   [**Registry**][] - быстрый доступ к системным константам

-   **Часть третья**

    -   [**Acl**][] - расширенный пример

Маршрутизация
-------------

Маршрутизация - очень важная тема. Как вы знаете, по-умолчанию, в Zend
Framework используются url формата -
controller/action/param1/value1/param2/value2. Именно благодаря
средствам маршрутизации мы можем организовывать url такого формата,
который требуется в проекте. К примеру, вы можете организовать простой
доступ к статическим страницам через url вида - site.com/static-page или
реализовать доступ к товарам через ссылки вида -
site.com/catalog/category/good-name. В особенности это полезно для нужд
seo, но также помогает пользователям при получении ссылок, сразу понять
что находится на странице сайта.

Рассмотрим пример создания маршрутов для ссылок форматов указанных выше.
Для начала нужно сформировать маршруты, для этого напишем метод в файле
bootstrap.php:

    :::php
    <?php
    // ...
    public function _initRoute(){
        // Получаем маршрут, по-умолчанию
        $router = Zend_Controller_Front::getInstance()->getRouter();
        // создаем пользовательские маршруты
        // маршрут для статических страниц
        $route_static = new Zend_Controller_Router_Route(
                '/:page',
                array(
                    'controller' => 'static',
                    'action' => 'index',
                    'page' => 'default-page-name'
                ), 
                array(
                    'page' => '[\w\-]+'
                )
        );
        $router->addRoute('static', $route_static);
        // маршрут для товаров
        $route_goods = new Zend_Controller_Router_Route(
                '/catalog/:category/:good/*',
                array(
                    'controller' => 'goods',
                    'action' => 'show'
                ), 
                array(
                    'category' => '[\w\-]+',
                    'good' => '[\w\-]+'
                )
        );
        $router->addRoute('goods', $route_goods);
    }

Сначала мы получаем стандартный маршрутизатор и добавляем к нему
пользовательские маршруты. В данном случае мы используем
перезаписывающий маршрутизатор Zend\_Controller\_Router\_Route. Первым
параметром конструктору маршрутизатора передается строка описывающая
формат url. Для задания динамических частей используются идентификаторы
вида ":variable". Такие динамические части удобно рассматривать как
переменные, значения которых подставляются из определенного участка url.
Вторым параметром передается массив стандартных значений маршрутизатора.
В данном массиве нужно указать значения названия контроллера и экшена
который будет обрабатывать запрос по данному маршруту, а также значения
переменных по-умолчанию, которые будут использоваться в случае если
соответствующее значение url пропущено. Также удобным бывает задать
требования к переменным. Для этого третьим параметром необходимо
передать паттерн, который описывает формат допустимого значения
переменной. Я рекомендую указывать данный параметр всегда, когда это
возможно. Это полезно в целях безопасности, т.к. в случае не совпадения
шаблона со значением переменной, будет инициирована ошибка и код экшена
не получит потенциально опасного значения.

После создания маршрутизатора, нам необходимо добавить его в стандартный
маршрутизатор при помощи метода addRoute. Каждому маршруту должна
соответствовать уникальная строка-идентификатор, которая будет
использована нами в дальнейшем.

Далее в коде действия для того чтобы получить значение переменной нам
необходимо выполнить следующий код:

    :::php
    <?php
    // ...
    $page = $this->getRequest()->getParam('page');

Также нам может потребоваться создание ссылок с использованием данного
маршрутизатора. Для этого воспользуемся стандартным помощником вида url.

    :::html+php
    <a href="<?php $this->url(array('page'=>'about'), 'test'); ?>">О проекте</a>

Мы рассмотрели только один из маршрутизаторов используемых в Zend
Framework. Подробнее можете прочитать в документации [здесь][].

Registry
--------

Сейчас мы рассмотрим, как в ZF можно организовать удобный и быстрый
доступ к константам из секции файла application.ini. Для начала зададим
несколько констант:

    :::ini
    [constants]paths.photo = "/photo/"paths.uploads = "/uploads/"paths.video = "/video/"secret_code = "key_for_check"

Код выше необходимо разместить в файле application.ini. Далее
воспользуемся компонентом Zend\_Registry, который реализует паттерн
Registry, для того чтобы сделать наши константы доступными во всем
проекте:

    :::php
    <?php
    // ...
    public function _initConfig(){
        Zend_Registry::set('constants',  new Zend_Config_Ini(APPLICATION_PATH . '/configs/application.ini', 'constants'));
    }

Метод представленный выше нужно добавить в bootstrap.php. Далее, чтобы
обратится к константе используем следующий код:

    :::php
    <?php
    // ...
    $path_photo = Zend_Registry::get('constants')->paths->photo;

  [ZendFramework logo]: /media/2011/06/ZendFramework-logo-640x169.png
    "ZendFramework logo"
  [**Часть первая**]: /PHP/praktikum-zend-framework-chast-pervaia-autentifikatsiia-i-acl/
  [**Аутентификация**]: /PHP/praktikum-zend-framework-chast-pervaia-autentifikatsiia-i-acl/#auth
  [**ACL**]: /PHP/praktikum-zend-framework-chast-pervaia-autentifikatsiia-i-acl/#acl
  [**Маршрутизация**]: #route
  [**Registry**]: #registry
  [**Acl**]: /PHP/praktikum-zend-framework-chast-tretiazend_acl/
  [здесь]: http://framework.zend.com/manual/ru/zend.controller.router.html
