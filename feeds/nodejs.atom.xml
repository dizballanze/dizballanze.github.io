<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Tech blog by @dizballanze</title><link href="/" rel="alternate"></link><link href="http://dizballanze.com/feeds/nodejs.atom.xml" rel="self"></link><id>/</id><updated>2014-03-15T23:46:00+04:00</updated><entry><title>Серверная архитектура DebugMail</title><link href="/nodejs/servernaia-arkhitektura-debugmail/" rel="alternate"></link><updated>2014-03-15T23:46:00+04:00</updated><author><name>Admin</name></author><id>tag:,2014-03-15:nodejs/servernaia-arkhitektura-debugmail/</id><summary type="html">&lt;p&gt;&lt;img alt="debugmail-logo" src="/media/2014/3/debugmail.jpg" title="DebugMail" /&gt;&lt;/p&gt;
&lt;p&gt;На днях &lt;a href="http://wbtech.ru"&gt;мы&lt;/a&gt; запустили &lt;a href="http://debugmail.io/"&gt;DebugMail&lt;/a&gt; - сервис, который помогает упростить тестирование email-рассылок на этапе разработки сайта/приложения/etc. Сервис позволяет сразу после регистрации получить свой виртуальный smtp-сервер, просматривать отправляемые письма, совместно работать над рассылками вместе с коллегами. В этом посте я расскажу про то, как разрабатывался backend сервиса, какие технологии использовались и какие проблемы приходилось решать. Думаю пост будет интересен прежде всего тем, кто работает с Node.js. &lt;/p&gt;
&lt;p&gt;Основные используемые технологии:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt; для запуска нашего js на сервере.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt;, чтобы добавить немного сахара к нашему js.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.mongodb.org/"&gt;MongoDB&lt;/a&gt; для хранения всех перманентных данных. &lt;a href="http://mongoosejs.com/"&gt;Mongoose&lt;/a&gt; - ODM для работы с MongoDB из под Node.js.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;, как хранилище для сессий, кэш и для поддержки работы сервера real-time обновлений (&lt;a href="http://redis.io/topics/pubsub"&gt;pub/sub&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;a href="http://faye.jcoglan.com/"&gt;Faye&lt;/a&gt; система для обмена real-time сообщениями между клиентом и сервером при помощи паттерна pub/sub.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Backend сервиса состоит 3 основных компонентов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SMTP-сервер, который сохраняет все полученные письма и умеет отличать проект к которому относится письмо.&lt;/li&gt;
&lt;li&gt;REST Api который позволяет выполнять операции по работе с проектами, пользователями и письмами.&lt;/li&gt;
&lt;li&gt;Сервер для поддержки real-time обновлений при получении новых писем.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Для того, чтобы сервис было легче масштабировать, каждый из описанных выше компонентов разрабатывался с учетом того, что он может быть запущен отдельно, в том числе на другом сервере. Взаимодействие между компонентами в основном происходит через базу данных и систему обмена сообщениями Faye (для real-time обновлений).&lt;/p&gt;
&lt;p&gt;&lt;img alt="debugmail-design" src="/media/2014/3/debugmail-design.png" title="DebugMail design" /&gt;&lt;/p&gt;
&lt;h2 id="smtp-"&gt;SMTP-сервер&lt;/h2&gt;
&lt;p&gt;Необходимо было разработать SMTP-север, который бы не осуществлял доставку письма на целевой хост, а только сохранял его в базе данных. В этом нам отлично помогли модули &lt;a href="https://github.com/andris9/simplesmtp"&gt;simplesmtp&lt;/a&gt; и &lt;a href="https://github.com/andris9/mailparser"&gt;mailparser&lt;/a&gt;, которые покрывали все базовые функции необходимые для работы smtp-сервера и парсинга писем. Оставалось только прописать нужные обработчики событий и другой специфичный для задачи код.&lt;/p&gt;
&lt;p&gt;В сервисе предполагается, что все письма относятся к определенному проекту. При создании проекта пользователь получает параметры подключения к smtp-серверу среди которых есть пара login-password. На основе этих данных smtp-сервер определяет к какому проекту относится то или иное полученное письмо.&lt;/p&gt;
&lt;h2 id="rest-api"&gt;REST API&lt;/h2&gt;
&lt;p&gt;Для взаимодействия клиентского приложения (см. скоро пост про клиентскую часть) с backend было разработано REST API на базе фреймворка &lt;a href="http://expressjs.com/"&gt;express&lt;/a&gt;. Выбран был именно этот фреймворк из-за его простоты, скорости работы и гибкости. При помощи поддержки middleware, которые пришли из &lt;a href="http://www.senchalabs.org/connect/"&gt;connect&lt;/a&gt;, можно очень просто встраиваться в процесс обработки запросов. Несколько примеров разработанных middleware:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;контроль доступа,&lt;/li&gt;
&lt;li&gt;content negotiation,&lt;/li&gt;
&lt;li&gt;защита от CSRF,&lt;/li&gt;
&lt;li&gt;инициализация сессии и тд.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="content-negotiation"&gt;Content negotiation&lt;/h3&gt;
&lt;p&gt;Для того, чтобы максимально распараллелить работу с front-end разработчиком, было принято решение реализовывать сервис в виде SPA (single page application) и REST API. Далее возник вопрос, как различать запросы, которые отправляет клиентское приложение, от запросов, которые генерируются браузером автоматически (при загрузке страниц) при том, то URL-адреса REST API и клиентского приложения пересекаются. Самым корректным решением нам показалось использование content negotiation. При поступлении запроса срабатывает middleware, который проверяет какой формат ответа является предпочтительным для клиента, на основании значения из заголовка запроса &lt;code&gt;Accept&lt;/code&gt;. Клиентское приложение отправляет значение данного заголовка как &lt;code&gt;application/json&lt;/code&gt;, что сообщает серверу о том, что нужно обрабатывать запрос, как запрос к REST API и вернуть результат в виде JSON-документа. Во всех остальных случаях предполагается, что запрос приходит от браузера и происходит рендеринг основного шаблона с подключенным клиентским приложением.&lt;/p&gt;
&lt;h3 id="_1"&gt;Маршрутизация&lt;/h3&gt;
&lt;p&gt;Изначально было принято решение использовать модуль &lt;a href="https://github.com/visionmedia/express-resource"&gt;express-resource&lt;/a&gt;, но он оказался недостаточно гибким. Например, нельзя задавать кастомные middleware для определенных маршрутов. &lt;a href="https://github.com/visionmedia/express-resource/pull/66"&gt;Pull Request&lt;/a&gt; для решения описанной проблемы висит уже больше года, в итоге от &lt;code&gt;express-resource&lt;/code&gt; пришлось отказаться в пользу стандартного способа задания маршрутов в express.&lt;/p&gt;
&lt;h2 id="real-time-updates"&gt;Real-time updates&lt;/h2&gt;
&lt;p&gt;Одна из фич сервиса предполагает, что при получении нового письма оно должна сразу появляться в интерфейсе. Для реализации таких real-time обновлений существует несколько популярных решений:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://socket.io"&gt;socket.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://sockjs.org"&gt;sockjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://faye.jcoglan.com/"&gt;faye&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Мы остановились на Faye, т.к. он:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;имеет достаточно удобное и простое API,&lt;/li&gt;
&lt;li&gt;из коробки поддерживаются server-side clients, что важно, т.к. сообщения генерируются из SMTP-сервера,&lt;/li&gt;
&lt;li&gt;достаточно активно разрабатывается.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;Аутентификация пользователей&lt;/h3&gt;
&lt;p&gt;Основной сложностью было реализовать аутентификацию клиентов, т.к. сессии, которые используются в основном приложении и REST API, здесь не доступны. Для решения этой проблемы была введена аутентификация при подписке на обновления проекта. Предпологается, что при инициализации подписки на уведомления клиент передает &lt;code&gt;user id&lt;/code&gt;, &lt;code&gt;session id&lt;/code&gt; и &lt;code&gt;token&lt;/code&gt;. &lt;code&gt;token&lt;/code&gt; является результатом выполнения хэш-функции к параметрам &lt;code&gt;user id&lt;/code&gt;, &lt;code&gt;session id&lt;/code&gt; и некоторого закрытого ключа. Чтобы реализовать такой механизм отлично подходят, т.н. &lt;a href="http://faye.jcoglan.com/browser/extensions.html"&gt;extensions&lt;/a&gt;, которые позволяют перехватывать сообщения и выполнять дополнительные действия (проверки, дополнительную обработку данных и тд.). В итоге получается примерно такой код:&lt;/p&gt;
&lt;pre&gt;&lt;code class="javascript"&gt;client.addExtension({
  outgoing: function(message, callback) {
    if (message.channel !== '/meta/subscribe')
      return callback(message);

    message.ext = message.ext || {};
    message.ext.uid = USER_ID;
    message.ext.sid = SESSION_ID;
    message.ext.token = PRIVATE_TOKEN;
    callback(message);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Аналогичная система расширений на стороне сервера позволяет выполнять проверку и разрешать подписываться на обновления по проектам только тем пользователям, которые действительно имеют к ним доступ.&lt;/p&gt;
&lt;h2 id="_3"&gt;Автоматическое тестирование&lt;/h2&gt;
&lt;p&gt;Зачем нужно писать тесты я думаю объяснять не нужно. В данном проекте мы хотели добиться максимального покрытия кода тестами. Для этого практически весь код тестируется сразу на 2х уровнях, на функциональном и на модульном.&lt;/p&gt;
&lt;p&gt;Писать тесты на node.js - одно удовольствие. В основном это так благодаря большому количеству удобных инструментов и модулей в &lt;a href="https://npmjs.org/"&gt;npm&lt;/a&gt;. Также помогают особенностям javascript и node.js, которые предоставляют все необходимые возможности для удобного создания &lt;a href="http://en.wikipedia.org/wiki/Mock_object"&gt;моков&lt;/a&gt;. Рассмотрим, какие модули использовались и с какой целью:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://visionmedia.github.io/mocha/"&gt;mocha&lt;/a&gt; - многофункциональный тестовый фреймворк, содержит все необходимые функции для структурирования, поиска, запуска, подсчета метрик, просмотра результатов выполнения тестов и тд. Поддерживает как синхронные так и асинхронные тесты и имеет широкие возможности для кастомизации процесса тестирования.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/visionmedia/supertest"&gt;supertest&lt;/a&gt; - модуль для выполнения функционального тестирования. Все что нужно для начала работы с supertest - передать ему экземпляр приложения express, после этого можно выполнять запросы к приложению и тестировать полученные ответы. Также supertest предоставляет удобный chaining api, типичный тест выглядит так:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="javascript"&gt;request(app)
  .get('/user')
  .set('Accept', 'application/json')
  .expect(200)
  .end(function(err, res){
    if (err) return done(err);

    // ... check something here ...

    done()
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/visionmedia/should.js/"&gt;should.js&lt;/a&gt; - это библиотека для удобного выполнения assertions. При инициализации библиотека перегружает встроенные объекты javascript, что позволяет использовать красивые конструкции вроде &lt;code&gt;user.should.have.property('company', 'wbtech')&lt;/code&gt;. Предоставляет большое количество полезных фич, что делает написание тестов более приятным и быстрым процессом.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/felixge/node-sandboxed-module"&gt;sandboxed-module&lt;/a&gt; - модуль для &lt;a href="http://en.wikipedia.org/wiki/Dependency_injection"&gt;dependency injection&lt;/a&gt;. Позволяет загрузить модуль с подменой указанных модулей, а также локальных и глобальных переменных.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pgte/nock"&gt;nock&lt;/a&gt; - позволяет перехватывать запросы, которые делает код, через http протокол. Можно переопределять все запросы или по определенным признакам (например, url запроса, заголовки или тело запроса) и задавать ответ, который будет возвращаться в вызываемый код. Есть много дополнительных плюшек, вроде задания задержек, chaining api и тд.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Стоит отметить, что тесты выполняются очень быстро. На данный момент 320 тестов выполняются примерно за 17с (в один поток).&lt;/p&gt;
&lt;h2 id="_4"&gt;Некоторые используемые модули&lt;/h2&gt;
&lt;p&gt;Список некоторых полезных модулей, о которых не упоминал выше:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/caolan/async"&gt;async&lt;/a&gt;, &lt;a href="http://lodash.com/"&gt;lodash&lt;/a&gt; - незаменимые модули, полезны практически в каждом проекте.&lt;ul&gt;
&lt;li&gt;async предоставляет очень простой способ для выполнения асинхронного кода.&lt;/li&gt;
&lt;li&gt;lodash модуль для упрощения работы с различными структурами данных, также содержит методы для упрощения функционального программирования и &lt;a href="http://lodash.com/docs"&gt;многое другое&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ectjs.com/"&gt;ect&lt;/a&gt; - очень быстрый и в тоже время гибкий шаблонизатор, который работает с синтаксисом CoffeeScript.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.nodemailer.com/"&gt;nodemailer&lt;/a&gt; - для отправки писем, есть все что нужно, кастомизируется.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://passportjs.org/"&gt;passport&lt;/a&gt; - все что нужно для аутентификации через сторонние ресурсы. Поддерживает &lt;a href="https://github.com/jaredhanson/passport/wiki/Strategies#providers"&gt;множество провайдеров&lt;/a&gt; через сторонние модули.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mattrobenolt/raven-node"&gt;raven-node&lt;/a&gt; - node.js клент к &lt;a href="https://getsentry.com/"&gt;Sentry&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="node.js"></category><category term="mongodb"></category><category term="faye"></category><category term="debugmail"></category></entry><entry><title>Используем сессию express в socket.io</title><link href="/nodejs/ispolzuem-sessiiu-express-v-socketio/" rel="alternate"></link><updated>2013-04-19T13:33:00+04:00</updated><author><name>Admin</name></author><id>tag:,2013-04-19:nodejs/ispolzuem-sessiiu-express-v-socketio/</id><summary type="html">&lt;p&gt;При разработке приложения с использованием socket.io + express часто возникает задача использования сессии express в socket.io. Рассмотрим, как можно решить эту задачу.&lt;/p&gt;
&lt;h2 id="_1"&gt;Используемые пакеты&lt;/h2&gt;
&lt;p&gt;Нам нужно установить несколько пакетов, которые пригодятся для решения поставленной задачи (предполагается что express и soket.io уже установлены):&lt;/p&gt;
&lt;pre&gt;&lt;code class="bash"&gt;npm install cookie express-session-mongo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cookie&lt;/code&gt; - модуль для удобного парсинга cookie&lt;/li&gt;
&lt;li&gt;&lt;code&gt;express-session-mongo&lt;/code&gt; - back-end для хранения сессий express в MongoDB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="express"&gt;Настраиваем express&lt;/h2&gt;
&lt;p&gt;Настроим сессии в express:&lt;/p&gt;
&lt;pre&gt;&lt;code class="javascript"&gt;var DB = {
  'ip': '127.0.0.1',
  'port': 27017,
  'db': 'test'
}

var MongoSessionStore = require('express-session-mongo')
  , session_storage = new MongoSessionStore(DB);

var app = express();

app.configure(function(){

  /* .... */

  app.use(express.cookieParser('secret'));
  app.use(express.session({
    store: session_storage,
    secret: 'secret',
    key: 'sid'
  }));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данном примере мы используем MongoDB для хранения сессий, но данный приём будет работать и для других хранилищ.&lt;/p&gt;
&lt;h2 id="soketio"&gt;Получаем сессионные данные в soket.io&lt;/h2&gt;
&lt;pre&gt;&lt;code class="javascript"&gt;// Запускаем web-сервер
var server = http.createServer(app).listen(app.get('port'), function(){
  console.log(&amp;quot;Express server listening on port &amp;quot; + app.get('port'));
});

var io = socketio.listen(server);

// Настраиваем socket.io
io.configure(function() {

  // Аутентификация пользователей
  io.set('authorization', function (data, accept) {
    // Проверяем переданы ли cookie
    if (!data.headers.cookie) 
      return accept('No cookie transmitted.', false);

    // Парсим cookie
    data.cookie = cookie.parse(data.headers.cookie);

    // Получаем идентификатор сессии
    var sid = data.cookie['sid'];

    if (!sid) {
      accept(null, false);
    }

    sid = sid.substr(2).split('.');
    sid = sid[0];
    data.sessionID = sid;

    // Добавляем метод для чтения сессии
    // в handshakeData
    data.getSession = function(cb) {
      // Запрашиваем сессию из хранилища
      session_storage.get(sid, function(err, session) {
        if (err || !session) {
          console.log(err);
          accept(err, false);
          return;
        }
        cb(err, session);
      });
    }
    accept(null, true);
  });
});


// Пример использования
io.sockets.on('connection', function(socket) {
  socket.join('chat');

  socket.on('message', function(data) {
    socket.handshake.getSession(function(err, session) {
      data['user'] = session.name || 'guest';
      io.sockets.in('chat').emit('message', data);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для чтения сессии в обработчиках socket.io нужно использовать &lt;code&gt;socket.handshake.getSession&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="_2"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Стоит отметить, что если socket.io у вас слушает другой хост/порт, отличный от express, то необходимо предусмотреть другой способ передачи идентификатора сессии.&lt;/p&gt;
&lt;p&gt;Полный пример можно посмотреть на &lt;a href="https://github.com/dizballanze/express-socketio-session-example/"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary><category term="node.js"></category><category term="express"></category><category term="socket.io"></category></entry><entry><title>Масштабирование Node.js приложений</title><link href="/nodejs/masshtabirovanie-nodejs-prilozhenii/" rel="alternate"></link><updated>2013-02-17T01:17:00+04:00</updated><author><name>Admin</name></author><id>tag:,2013-02-17:nodejs/masshtabirovanie-nodejs-prilozhenii/</id><summary type="html">&lt;p&gt;Все мы знаем, что node.js так популярен благодаря своей производительности. Он работает быстро благодаря разным факторам, таким как использование движка Google V8 и асинхронному i/o. Именно такая высокая производительность позволяет достаточно долго не задумываться о масштабировании приложения, т.к. даже один запущенный Node.js процесс может обслуживать сотни или даже тысячи запросов в секунду.&lt;/p&gt;
&lt;p&gt;&lt;img alt="postlogo" src="/media/2013/02/node-cluster.png" /&gt;&lt;/p&gt;
&lt;p&gt;Изначально Node.js приложение работает в одном потоке и, соответственно, для обработки запросов используется только одно ядро процессора. Чтобы использовать весь потенциал многоядерных процессоров, необходимо запускать сразу несколько экземпляров приложения, а операционная система позаботится о том, чтобы каждый из них получил вычислительные ресурсы.&lt;/p&gt;
&lt;p&gt;Количество потоков лучше всего подбирать опытным путём. Изменяя количество потоков и проводя тестирование производительности. Чаще всего берут количество потоков равное количеству ядер процессора (или количество_ядер + 1).&lt;/p&gt;
&lt;p&gt;Сегодня мы рассмотрим: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;каким требованиям должно соответствовать приложение, чтобы успешно масштабироваться&lt;/li&gt;
&lt;li&gt;существующие npm-модули для масштабирования&lt;/li&gt;
&lt;li&gt;сторонние программные решения&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt;Подготовка к масштабированию&lt;/h2&gt;
&lt;p&gt;Перед тем как приложение будет иметь возможность работать в несколько потоков, нужно решить одну очень важную проблему. А именно, проблему хранения сессий и других, зависимых от клиента, данных в промежутках между запросами.&lt;/p&gt;
&lt;p&gt;Когда приложение работает в одном потоке, всё предельно просто. Данные можно хранить в переменных процесса и они будут доступны при каждом запросе. Многие так и поступают в начале разработки и, например, используют массивы для хранения сессионных данных пользователей. &lt;/p&gt;
&lt;p&gt;Однако для работы приложения в многопоточном режиме, необходимо убедится в том что каждый процесс может обслужить любой пользовательский запрос. Т.е. все процессы должны быть равноправны и иметь доступ ко всей необходимой информации о пользователях и сессиях.&lt;/p&gt;
&lt;p&gt;Одним из простых способов решения данной проблемы является вынесение сессионных данных во внешнее хранилище (например: Memcached, Redis и тд.) и запрос необходимых данных в начале обработки каждого запроса. Эту схему можно изобразить следующим образом:&lt;/p&gt;
&lt;p&gt;&lt;img alt="loadbalancing" src="/media/2013/02/load-balancing.png" /&gt;&lt;/p&gt;
&lt;h2 id="nodejs"&gt;Решения на Node.js&lt;/h2&gt;
&lt;h3 id="cluster"&gt;cluster&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://nodejs.org/api/cluster.html"&gt;Cluster&lt;/a&gt; - это built-in модуль, позволяющий с лёгкостью запускать несколько процессов, которые делят между собой один порт. В данном случае балансировкой нагрузки занимается операционная система. На момент написания данного поста, модуль является экспериментальным, но мы всё же протестируем его в работе.&lt;/p&gt;
&lt;p&gt;В данном случае при запуске приложения необходимо сначала запустить master-процесс, который в свою очередь, запустит необходимое количество дочерних процессов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var cluster = require('cluster');

cluster.setupMaster({exec: __dirname + '/worker.js'});

for (var i = 0; i &amp;lt; 4; i++) {
    cluster.fork();
}

cluster.on('exit', function(worker, code, signal) {
    console.log('worker ' + worker.process.pid + ' died');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;setupMaster&lt;/code&gt; принимает параметры в виде объекта. Например, параметр &lt;code&gt;exec&lt;/code&gt; задаёт путь к файлу worker'а, который затем будет запускаться на выполнение.&lt;/p&gt;
&lt;p&gt;После начальной конфигурации master-север должен запустить необходимое количество рабочих процессов. Для этого используется метод &lt;code&gt;fork&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var cluster = require('cluster');
var http = require('http');

http.createServer(function(req, res) {
    res.writeHead(200);
    res.end("hello world\n");
}).listen(7000);
console.log("Worker listen on 127.0.0.1:7000");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Создание worker'а мало чем отличается от создания обычного web-сервера. В данном случае мы просто создаём http-сервер и заставляем его слушать 7000 порт.&lt;/p&gt;
&lt;h3 id="cluster2"&gt;cluster2&lt;/h3&gt;
&lt;p&gt;Cluster2 - модуль от сторонних разработчиков, расширяющий возможности стандартного модуля cluster. Модуль добавляет функции, которые позволяют использовать cluster в production окружении. Среди таких функций:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;перезапуск рабочих процессов&lt;/li&gt;
&lt;li&gt;таймаут простоя&lt;/li&gt;
&lt;li&gt;события для логирования&lt;/li&gt;
&lt;li&gt;осторожное завершение процессов и др&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Подробнее ознакомится с модулем можно на &lt;a href="https://github.com/ql-io/cluster2"&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="etc"&gt;etc&lt;/h3&gt;
&lt;p&gt;Ещё несколько модулей:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/fent/clusterhub"&gt;clusterhub&lt;/a&gt; - an attempt at giving multi process node programs a simple and efficient way to share data&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/isaacs/cluster-master"&gt;cluster-master&lt;/a&gt; - take advantage of node built-in cluster module behavior&lt;/li&gt;
&lt;li&gt;&lt;a href="https://npmjs.org/package/amino"&gt;amino&lt;/a&gt; - clustering framework for Node.js&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;Сторонние программные решения&lt;/h2&gt;
&lt;h3 id="haproxy"&gt;HAProxy&lt;/h3&gt;
&lt;p&gt;HAProxy - это специализированное решение для балансировки нагрузок. Содержит огромное количество функций и используется во многих highload проектах. Рассмотрим пример простейшей конфигурации системы на HAProxy.&lt;/p&gt;
&lt;p&gt;Для начала необходимо скачать и установить HAProxy, например &lt;a href="http://haproxy.1wt.eu/"&gt;с официального сайта&lt;/a&gt;. После этого нужно создать конфигурационный файл:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::text
global
daemon
maxconn 10000

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend http-in
    bind *:80
    default_backend servers

backend servers
    balance roundrobin
    server server1 127.0.0.1:8000
    server server2 127.0.0.1:8001
    server server3 127.0.0.1:8002
    server server4 127.0.0.1:8003
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если коротко, то данный конфигурационный файл описывает, что HAProxy должен прослушивать 80 порт и перенаправлять каждый запрос на один из серверов, указанны в секции backend. При этом, какой именно сервер получит запрос определяется по алгоритму &lt;a href="http://ru.wikipedia.org/wiki/Round-robin_(%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)"&gt;round-robin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Node.js приложение необходимо запустить на каждом из указанных портов. При этом какой-то особенной конфигурации приложения не требуется.&lt;/p&gt;
&lt;p&gt;HAProxy достаточно сложное решение и больше подходит для очень крупных проектов, где необходимо распределять нагрузку между большим количеством физических серверов или между целыми кластерами.&lt;/p&gt;
&lt;h3 id="nginx"&gt;Nginx&lt;/h3&gt;
&lt;p&gt;Nginx позволяет описывать группы серверов в конфигурационных файлах и затем балансировать нагрузку между ними при помощи одного из нескольких алгоритмов. Есть возможность задания "веса" сервера, выделение отдельных серверов как резервных и др. &lt;/p&gt;
&lt;p&gt;Предположим у нас запущены 8 процессов нашего приложения. Каждый процесс слушает порт, первый процесс - 8000, второй - 8001, и тд. Рассмотрим простой пример конфигурации Nginx для балансировки нагрузки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::nginx
upstream backend {
    least_conn;
    server 127.0.0.1:8000;
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
    server 127.0.0.1:8003;
    server 127.0.0.1:8004;
    server 127.0.0.1:8005;
    server 127.0.0.1:8006;
    server 127.0.0.1:8007;
}

server {
    listen 0.0.0.0:80;

    location / {
    proxy_pass http://backend;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь Nginx будет принимать запросы на 80 порт и балансировать их между процессами приложения. При этом он будет стараться отдавать запрос тому процессу, который в данный момент меньше всего нагружен.&lt;/p&gt;
&lt;h3 id="etc_1"&gt;etc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Round-robin_DNS"&gt;Round-robin DNS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.apsis.ch/pound/"&gt;Pound&lt;/a&gt; - reverse proxy, load balancer and HTTPS front-end for Web server(s)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/perlbal/Perlbal"&gt;Perlbal&lt;/a&gt; - Perl HTTP Load Balancer&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Какой именно способ выбрать зависит от конкретного случая. Мне кажется, для масштабирования в рамках одного сервера, лучше использовать модуль cluster (или его производные), т.к. это упрощает контроль за запущенными рабочими процессами. В случае если приложение требует вынести на несколько серверов, нужно просто создать несколько таких кластеров и настроить балансировку между ними при помощи Nginx или HAProxy.&lt;/p&gt;
&lt;style type="text/css"&gt;
img[alt=loadbalancing] {margin-left: 130px;}
&lt;/style&gt;</summary><category term="cluster"></category><category term="load balancing"></category><category term="clustering"></category><category term="scaling"></category></entry><entry><title>CoffeeScript &amp; node.js dev-сервер</title><link href="/nodejs/coffeescript-nodejs-dev-server/" rel="alternate"></link><updated>2013-01-19T22:10:00+04:00</updated><author><name>Admin</name></author><id>tag:,2013-01-19:nodejs/coffeescript-nodejs-dev-server/</id><summary type="html">&lt;p&gt;CoffeeScript - язык программирования, компилируемый в javascript. Используя &lt;a href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt; для разработки на &lt;a href="/tag/nodejs/"&gt;node.js&lt;/a&gt; мы можем избавиться от некоторых, не очень приятных, особенностей javascript.
&lt;img alt="node.js and coffee-script" src="media/2013/01/nodejs-and-coffeescript.png" title="node.js and coffee-script" /&gt;
Сегодня мы рассмотрим, как автоматизировать процесс компиляции CoffeeScript в javascript. Также настроим автоматическую перезагрузку приложения, после каждой новой компиляции.&lt;/p&gt;
&lt;h1 id="_1"&gt;Устанавливаем пакеты&lt;/h1&gt;
&lt;p&gt;Для выполнения нашей цели необходимо установить несколько пакетов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
npm install coffee-script forever
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы установили следующие пакеты&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;coffee-script&lt;/code&gt; - cli-утилита для компиляции CoffeeScript&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forever&lt;/code&gt; - утилита для удобного запуска node.js процессов&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;Файловая структура&lt;/h1&gt;
&lt;p&gt;Всё приложение (файлы с расширением *.coffee) располагаем в отдельной поддиректории. Для скомпилированных файлов создаём дополнительную поддиректорию в корне проекта. Также важно чтобы временные файлы, файлы загруженные пользователями и т.д. находились в отдельной от приложения поддиректории. Т.е. получаем примерно следующую файловую структуру:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
$ ls -1
app
compiled
node_modules
package.json
README.md
uploads
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Где,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;app/&lt;/code&gt; - приложение (файлы *.coffee)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compiled/&lt;/code&gt; - скопмилированные js файлы&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uploads/&lt;/code&gt; - загрузки пользователей&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="coffeescript"&gt;Компилируем CoffeeScript&lt;/h1&gt;
&lt;p&gt;Для того чтобы компилировать CoffeeScript в javascript необходимо использовать утилиту &lt;code&gt;coffee&lt;/code&gt;. Она принимает ряд параметров, можете ознакомится с ней подробнее прочитав справочную информацию &lt;code&gt;coffee --help&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Утилита &lt;code&gt;coffee&lt;/code&gt; позволяет следить за файловой системой и автоматически перекомпилировать изменённые файлы CoffeeScript. Для этого необходимо вызвать её со следующими параметрами:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
 coffee -w -o compiled/ app/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Где, флаг &lt;code&gt;-w&lt;/code&gt; включает режим отслеживания, -o задаёт директорию, в которую сохраняются скомпилированные файлы, а последний параметр определяет целевую директорию приложения.&lt;/p&gt;
&lt;h1 id="_3"&gt;Настраиваем автоматический перезапуск приложения&lt;/h1&gt;
&lt;p&gt;Для того чтобы автоматически перезапускать приложения, после перекомпиляции, воспользуемся утилитой &lt;code&gt;forever&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
forever -w --watchDirectory compiled/ --sourceDiDir compiled/ compiled/app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Рассмотрим параметры:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt; - включаем режим отслеживания&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--watchDirectory&lt;/code&gt; - задаем директорию, изменения в которой необходимо отслеживать&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--sourceDir&lt;/code&gt; - задаем базовую директорию для запускаемого приложения&lt;/li&gt;
&lt;li&gt;и файл который необходимо запустить&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Теперь после каждого изменения в *.coffee файлах приложения будет автоматически запускаться перекомпиляция изменённых файлов. После этого изменения в скомпилированных файлах будет замечено утилитой &lt;code&gt;forever&lt;/code&gt;, что приведет к перезапуску приложения.&lt;/p&gt;</summary><category term="coffeescript"></category><category term="forever"></category><category term="node.js"></category></entry><entry><title>Используем npm для управления зависимостями</title><link href="/nodejs/ispolzuem-npm-dlia-upravleniia-zavisimostiami/" rel="alternate"></link><updated>2013-01-04T20:10:00+04:00</updated><author><name>Admin</name></author><id>tag:,2013-01-04:nodejs/ispolzuem-npm-dlia-upravleniia-zavisimostiami/</id><summary type="html">&lt;p&gt;npm - пакетный менеджер для &lt;a href="/tag/nodejs/" title="Node.js"&gt;node.js&lt;/a&gt;. Сегодня мы рассмотрим как использовать npm для управления зависимостями и автоматизации деплоймента.&lt;/p&gt;
&lt;p&gt;&lt;img alt="npm package management" src="media/2013/01/npm.png" title="node packaged modules" /&gt;&lt;/p&gt;
&lt;h1 id="npm"&gt;Установка npm&lt;/h1&gt;
&lt;p&gt;Если у вас не установлен &lt;code&gt;npm&lt;/code&gt;, то сделать это можно выполнив следующую команду:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
curl https://npmjs.org/install.sh | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="_1"&gt;Установка пакетов&lt;/h1&gt;
&lt;p&gt;Для того чтобы установить пакет при помощи &lt;code&gt;npm&lt;/code&gt; нужно использовать команду &lt;code&gt;npm install &amp;lt;package&amp;gt;&lt;/code&gt;.
Где &lt;code&gt;package&lt;/code&gt; может быть:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Путь к директории содержащей пакет описываемый файлом &lt;code&gt;package.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Архив в формате gzipped tarball&lt;/li&gt;
&lt;li&gt;URL для скачивания архива в формате gzipped tarball&lt;/li&gt;
&lt;li&gt;Название пакета в &lt;a href="https://npmjs.org/" title="Реестр пакетов npm"&gt;реестре пакетов&lt;/a&gt; с возможностью указания версии после знака &lt;code&gt;@&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;URL удаленного репозитория git&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;По-умолчания, установка будет произведена локально, в текущую директорию. Для того чтобы выполнить установку глобально
необходимо вызывать &lt;code&gt;npm&lt;/code&gt; с флагом &lt;code&gt;-g&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="_2"&gt;Управление зависимостями&lt;/h1&gt;
&lt;p&gt;При разработке приложений на &lt;a href="/tag/nodejs/" title="Node.js"&gt;node.js&lt;/a&gt; я использую множество различных модулей. Соответственно,
при разворачивании приложения необходимо быть уверенным, что в системе установлены все требуемые пакеты. Рассмотрим, как npm
помогает нам решить эту проблему.&lt;/p&gt;
&lt;p&gt;Для описания пакета npm использует файл &lt;code&gt;package.json&lt;/code&gt;, который размещается в корневой директории пакета. В файле содержится
большое количество разной информации о пакете, рекомендую вам ознакомиться с &lt;a href="https://npmjs.org/doc/json.html"&gt;форматом файла&lt;/a&gt;. Нас на данный момент интересует раздел &lt;a href="https://npmjs.org/doc/json.html#dependencies"&gt;dependencies&lt;/a&gt;, который содержит
список пакетов от которых зависит приложение. К счастью вручную заполнять этот список не придётся, т.к npm умеет генерировать
его самостоятельно. Для того, чтобы сгенерировать &lt;code&gt;package.json&lt;/code&gt; выполните команду &lt;code&gt;npm init&lt;/code&gt;, после чего вам необходимо будет ответить на несколько вопросов, вроде названия и версии пакета.&lt;/p&gt;
&lt;p&gt;Для того чтобы установить, содержащийся в &lt;code&gt;package.json&lt;/code&gt;, список пакетов необходимо выполнить команду &lt;code&gt;npm install&lt;/code&gt; без указания дополнительных аргументов. Соответственно, для того чтобы автоматизировать процесс установки зависимостей, нужно
поддерживать список зависимостей в &lt;code&gt;package.json&lt;/code&gt; в актуальном состоянии и при каждом обновлении/разворачивании приложения
выполнять команду &lt;code&gt;npm install&lt;/code&gt;.&lt;/p&gt;</summary><category term="npm"></category><category term="package.json"></category></entry><entry><title>Наследование свойств моделей в Mongoose</title><link href="/nodejs/nasledovanie-svoistv-modelei-v-mongoose/" rel="alternate"></link><updated>2013-01-02T02:41:00+04:00</updated><author><name>Admin</name></author><id>tag:,2013-01-02:nodejs/nasledovanie-svoistv-modelei-v-mongoose/</id><summary type="html">&lt;p&gt;Всех с прошедшим Новым Годом! Сегодня я покажу как наследовать свойства
моделей в &lt;a href="http://mongoosejs.com/" title="Mongoose ODM"&gt;ODM Mongoose&lt;/a&gt;. Для тех, кто не знает mongoose - это 
ODM (object document mapper) для node.js и &lt;a href="http://www.mongodb.org/" title="MongoDB"&gt;MongoDB&lt;/a&gt;. &lt;/p&gt;
&lt;h2 id="_1"&gt;Применение&lt;/h2&gt;
&lt;p&gt;Часто бывает необходимо в рамках одной коллекции объектов выделить несколько
типов с некоторыми различиями в наборе свойств. Т.к. MongoDB реализует schema-less дизайн, 
мы не ограничены базой данных и не обязаны следовать какому-то строгому набору
полей в наших коллекциях. Однако, удобнее использовать ODM, которые реализовывают
дополнительные плюшки, такие как валидация, фильтрация, методы модели и т.д.
Соответственно описание данных на уровне исходного кода модели все же остаётся.
Для того, чтобы решить проблему с типами объектов в рамках одной коллекции можно
наследовать базовые свойства и дополнять их специфическими для каждого типа объектов.&lt;/p&gt;
&lt;p&gt;Рассмотрим простой пример. У нас есть два типа пользователей: юридическое лицо и физическое
лицо. Каждый тип имеет общие и специфические поля. Чтобы выделить общие поля создадим объект
с набором полей, которые встречаются в каждом из типов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var BaseUser = {
    inn: {type: String, 
        validate: inn_validator,
        required: true},
    email: {type: String, required: true, unique: true,
        validate: email_validator},
    phone: {type: String, validate: phone_validator,
        required: true},
    username: {type: String, unique: true,
        required: true, validate: username_validator},
    password: {type: String, required: true, 
        validate: password_validator}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Далее для каждого из типов пользователей создаём объект со специфическими полями:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
// Физическое лицо
var IndividualPerson = {
    first_name: {type: String, required: true,
        validate: first_name_validator},
    last_name: {type: String, required: true,
        valdiate: last_name_validator},
    patronymic: {type: String, 
        validate: patronymic_validator},
    type: {type: String, default: 'individual'}
};

// Юридическое лицо
var LegalPerson = {
    full_name: {type: String, validate: full_name_validator, 
        required: true},
    short_name: {type: String, required: true, 
        validate: short_name_validator},
    type: {type: String, default: 'legal'}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Также мы добавили поле &lt;code&gt;type&lt;/code&gt; для дифференциации записей, т.к. они будут храниться в одной коллекции.
Далее необходимо просто при создании схемы модели выполнять слияние (merge) значений из &lt;code&gt;BaseUser&lt;/code&gt; и
соответствующего объекта типа:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
IndividualUserSchema = new Schema(Object.extended(BaseUser).merge(IndividualPerson));
LegalUserSchema = new Schema(Object.extended(BaseUser).merge(LegalPerson));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Здесь я использую &lt;a href="http://sugarjs.com/" title="Sugar.js"&gt;sugar.js&lt;/a&gt;, но при необходимости это можно реализовать
и вручную.&lt;/p&gt;
&lt;p&gt;Затем модели необходимо создавать таким образом, чтобы они использовали одну и ту же коллекцию в базе данных:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
exports.LegalUser = function(db) {
    return db.model('LegalUser', LegalUserSchema, 'users');
};

exports.IndividualUser = function(db) {
    return db.model('IndividualUser', IndividualUserSchema, 'users');
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="_2"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;В итоге мы получили две модели со своими наборами полей/валидаторов и при этом остались
преимущества использования одной коллекции - поиск записей по одной коллекции, уникальные
значения &lt;code&gt;username&lt;/code&gt; и &lt;code&gt;email&lt;/code&gt; через индексы и т.д.
При желании можно реализовать что-то вроде фабрики, чтобы при поиске в зависимости от значения
в поле &lt;code&gt;type&lt;/code&gt; создавался объект соответствующей модели.&lt;/p&gt;</summary><category term="mongoose"></category><category term="mongodb"></category><category term="node.js"></category><category term="sugar.js"></category></entry><entry><title>Очередь сообщений на node.js и memcacheq</title><link href="/nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/" rel="alternate"></link><updated>2011-10-07T23:24:00+04:00</updated><author><name>Admin</name></author><id>tag:,2011-10-07:nodejs/ochered-soobshchenii-na-nodejs-i-memcacheq/</id><summary type="html">&lt;p&gt;Привет! Столкнулся с необходимостью использования очередей сообщений в
текущем проекте. Знаю что есть готовые решения, но я все же решил
написать свой небольшой велосипед. Итак, поехали...&lt;/p&gt;
&lt;h2 id="_1"&gt;Описание&lt;/h2&gt;
&lt;p&gt;&lt;img alt="scheme" src="/media/2011/10/png" /&gt;&lt;/p&gt;
&lt;p&gt;В поставленной передо мной задаче необходимо выполнять ресурсоемкие
операции (такие как работа с сетью, декодирование mp3-файлов), а также
обращаться к бизнес-логике приложения для потока входных данных.
Приложение написано на php, поэтому очевидно что удобнее всего писать
worker'ы на этом языке в виде cli скриптов. В моем случае это сделать
очень просто, т.к. в проекте используется yii, а в нем есть
замечательная поддержка написания консольных команд при этом можно
использовать весь код бизнес-логики используемый в основном приложении.&lt;/p&gt;
&lt;p&gt;Для реализации хранения заданий отличным решением стало memcacheq.
Memcacheq - это сервис поддержки очередей с использованием api
memcached. Подробнее узнать о том что это за зверь можете на &lt;a href="http://memcachedb.org/memcacheq/"&gt;офф.
сайте&lt;/a&gt;. Стоит отметить что в связи с использованием BerkleyDB в
memcacheq есть ограничение на размер сообщения в очереди, которое
составляет около 64Кб, если для вас этого мало, то стоит подумать о
другом решении.&lt;/p&gt;
&lt;p&gt;Также потребуется менеджер очереди, который будет контролировать работу
воркеров (порождать, отслеживать статус выполнения, получать
результаты). Очевидно что менеджер должен работать постоянно и
периодически проверять нет ли новых заданий. Для реализации менеджера я
выбрал Node.js, как мне кажется это очень подходящая технология для этих
целей. В основном выбор пал на node из-за его асинхронности, возможности
легко и быстро написать демон, который будет вписываться в архитектуру
проекта и также на меня повлиял предыдущий опыт работы с данной
технологией, который оставил в основном положительные впечатления.&lt;/p&gt;
&lt;h2 id="_2"&gt;Реализация&lt;/h2&gt;
&lt;p&gt;На данном этапе у вас уже должен быть настроен и запущен memcacheq,
установлен nodejs. Также нам понадобиться модуль nodejs под названием
memcached. Установить его можно следующей командой:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
npm install memcached
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Основные составляющие части менеджера очереди:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Бесконечный цикл опроса очереди на наличие заданий. При этом также в
    цикле должна проводиться проверка на состояние запущенных worker'ов.
    Т.к. мы не можем себе позволить создание worker'ов в таком
    количестве в котором доступны задания, то нам необходимо ввести
    ограничение на количество одновременно обрабатываемых заданий. В
    данном цикле перед созданием новых потоков проверяется наличие
    свободного места, т.е. worker создается только в случае если
    количество текущих worker'ов меньше установленного ограничения.&lt;/li&gt;
&lt;li&gt;Объект worker'а - представляет из себя оболочку над процессом
    worker'а и хранит его состояние.&lt;/li&gt;
&lt;li&gt;Создание worker'а - процесс инициализации объекта worker'а на основе
    данных полученных от memcacheq&lt;/li&gt;
&lt;li&gt;Мониторинг. Для отслеживания состояния выполнения заданий создадим
    web-сервер который будет отвечать информацией о текущем статусе
    выполнения каждого выполняемого worker'а.&lt;/li&gt;
&lt;li&gt;Т.к. в моя задача связанна с передачей большого объема данных, то
    появилось необходимость ввести поправку на возможную ошибку передачи
    данных. Это подразумевает повторное занесение задания в очередь в
    случае если worker вернет ошибку передачи, которая может быть
    определена проверкой контрольной суммы передаваемых данных.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Теперь собственно исходный код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var util = require('util'),
    exec = require('child_process').exec;

var http = require('http');
var Memcached = require('./lib/memcached.js');
var memcached = new Memcached('127.0.0.1:22201', {maxValue:65000, reconnect:2000, retry:1000, timeout:10000});

var creating = false;
var workers_count = 2;
var transmit_error_retry_count = 3;
var workers = {};
var tasks = {};
var transmit_errors = {};
var command_line = '/path/to/worker/script';

// Возможные состояния процесса
var WORKER_SUCCESS_DONE = 1,
    WORKER_TRANSMIT_ERROR = 2,
    WORKER_CRITICAL_ERROR = 3,
    WORKER_IN_WORKING_PROCESS = 4;

// Функция выполняемая в бесконечном цикле
function check_feeds(){
    for (i in workers){
        if (workers[i].status == WORKER_SUCCESS_DONE){
            if (transmit_errors[i] != undefined)
                delete transmit_errors[i];
            delete workers[i];
            delete tasks[i];
        }else if(workers[i].status == WORKER_TRANSMIT_ERROR){
            if (transmit_errors[i] == undefined)
                transmit_errors[i] = 1;
            else
                transmit_errors[i]++;
            if (transmit_errors[i] &amp;lt; transmit_error_retry_count)
                push_back(tasks[i]);
            else{
                delete transmit_errors[i];
                delete tasks[i];
            }
            delete workers[i];
        }else if (workers[i].status != WORKER_IN_WORKING_PROCESS){
            if (transmit_errors[i] != undefined)
                delete transmit_errors[i];
            delete workers[i];
        }
    }

    // Если есть свободные места вызываем функцию
    // создающую worker'ов
    if (!creating &amp;amp;&amp;amp; (obj_count(workers) &amp;lt; workers_count))
        create_worker();
}

// Возвращение задания в очередь
function push_back(task){
    memcached.set("tracks", task, 0);
}

// Функция выполняющая создание новых worker'ов
function create_worker(){
    creating = true;
    memcached.get("tracks", function(err, result){
        if (!result)
            creating = false;
        else{
            check_feeds();
            work = JSON.parse(result);
            tasks[work['id']] = work;
            workers[work['id']] = new Worker(work);
            // Если все ещё есть свободные места
            // то делаем рекурсивный вызов
            if (obj_count(workers) &amp;lt; workers_count){
                create_worker();
            }else{
                creating = false;
            }
        }
    });
}

// Конструктор объекта worker'а
function Worker(id, data){
    this.status = WORKER_IN_WORKING_PROCESS;

    // Здесь можно сформировать 
    // параметры командной строки
    var params;

    exec(command_line + params, function(err, data){
        console.log(id, data);
        if (err)
            workers[id].status = WORKER_CRITICAL_ERROR;
        else
            workers[id].status = data;
    })
}

setInterval(function(){
    check_feeds();
}, 100);

// Monitoring server
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    for (i in workers){
        res.write(i +': ' + workers[i].status + "\n");
    }
    // Для того чтобы заработал след. код
    // необходимо внести изменения
    // в модуль memcache (см. ниже)
    memcached.queue(function (err, result){
        res.end('Queue:' + result);
    });
}).listen(8080, "127.0.0.1");

// Stuff
function obj_count(obj){
    var i = 0;
    for (j in obj) i++;
    return i;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для того чтобы корректно обрабатывать статусы выполнения задания
worker'ы должны возвращать определенные заранее значения. В моем случае
worker может вернуть одно из 3х состояний обозначенных в начале
исходного кода.&lt;/p&gt;
&lt;p&gt;Также стоит отметить, что для реализации отображения количества задач в
очереди memcacheq необходимо выполнить запрос stats queue, но модуль
memcached по всей видимости его не поддерживает. По-этому я внес
небольшие дополнения чтобы реализовать данный функционал. Исходный код
модуля доступен &lt;a href="http://pastebin.com/MgSFU6Gb"&gt;по ссылке&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="in-the-end"&gt;In the end..&lt;/h2&gt;
&lt;p&gt;Стоит заметить, что при помощи подобной организации системы вы сможете
распараллелить ресурсоемкие вычисления. Особенно это удобно, когда вам
необходимо обращаться к бизнес-логике написанной, например, на PHP. В
завершении хочу добавить что полученная система очереди сообщений сильно
направленная на реализацию поставленной передо мной задачи. Но я считаю,
что вы без проблем сможете доработать код для реализации нужного вам
функционала. Спасибо за внимание, буду рад ответить на возникшие
вопросы.&lt;/p&gt;</summary><category term="memcacheq"></category><category term="node.js"></category><category term="PHP"></category><category term="очередь сообщений"></category></entry><entry><title>Хранилища данных в Node.JS. Memcachedb</title><link href="/nodejs/khranilishcha-dannykh-v-nodejs-memcachedb/" rel="alternate"></link><updated>2011-07-02T23:04:00+04:00</updated><author><name>Admin</name></author><id>tag:,2011-07-02:nodejs/khranilishcha-dannykh-v-nodejs-memcachedb/</id><summary type="html">&lt;p&gt;&lt;img alt="MemcacheDB" src="/media/2011/07/Снимок-300x204.png" /&gt;&lt;/p&gt;
&lt;p&gt;Сегодня я расскажу, как начать работать с MemcacheDB в Node.JS.&lt;/p&gt;
&lt;h2 id="memcachedb"&gt;Memcachedb&lt;/h2&gt;
&lt;p&gt;Memcachedb - это key-value база данных, основанная на memcached. Для
тех, кто работал с memcached, начало работы с memcachedb не будет
требовать особых усилий, т.к. они используют общее API. Основные
возможности Memcachedb:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Распределенное хранилище пар ключ-значение&lt;/li&gt;
&lt;li&gt;В отличие от memcached не является решением для кеширования, т.к.
    хранит данные на диске&lt;/li&gt;
&lt;li&gt;В качестве движка хранилища используется Berkeley DB&lt;/li&gt;
&lt;li&gt;Поддержка транзакций&lt;/li&gt;
&lt;li&gt;Поддержка репликации&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Api memcachedb включает следующие команды:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get - получения значения по ключу или нескольким ключам&lt;/li&gt;
&lt;li&gt;set, add, replace - установка значения, сохранения значения
    только в случае если оно не было установлено ранее и установка
    значения только если оно было установлено ранее&lt;/li&gt;
&lt;li&gt;append / prepend - добавление данных в после существующего
    значения или перед ним&lt;/li&gt;
&lt;li&gt;incr / decr - инкремент, декремент значения&lt;/li&gt;
&lt;li&gt;delete - удаление значения&lt;/li&gt;
&lt;li&gt;stats - получение статистической информации&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="memcached"&gt;Установка модуля memcached&lt;/h2&gt;
&lt;p&gt;Как я уже упоминал memcacheDB имеет такое же API, как и у memcached
(кроме небольших изменений, например записи не удаляются по истечении
срока), поэтому мы будем использовать модуль предназначенный для работы
с memcached. Модуль имеет название memcached и доступен для установки
через npm:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
npm install memcached
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Я подразумеваю, что вы уже установили и запустили memcacheDB, если нет,
то вам &lt;a href="http://memcachedb.googlecode.com/svn/trunk/INSTALL"&gt;сюда&lt;/a&gt;. После установки модуля, мы сразу можем начать
использовать его в наших программах на node.js. Попробуем подключится к
БД:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var Memcached = require('memcached');
var memcached = new Memcached('127.0.0.1:21201');
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="hello-world"&gt;Пишем Hello World&lt;/h2&gt;
&lt;p&gt;Напишем скрипт, который сначала запишет значение в БД и затем считает
его и выведет в консоль:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var Memcached = require('memcached');
var memcachedb = new Memcached('127.0.0.1:21201');
memcachedb.set("test", "Hello world", 0, function(){
    memcachedb.get("test", function(err, result){
        if (err) throw err;
        console.log(result); // Hello world
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Подробную информацию по функциям api можете получить &lt;a href="https://github.com/3rd-Eden/node-memcached/blob/v0.0.1/README.md"&gt;здесь&lt;/a&gt; и в
&lt;a href="https://github.com/3rd-Eden/node-memcached/tree/v0.0.1/examples"&gt;примерах&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;На этом все. До новых постов!&lt;/p&gt;</summary><category term="memcachedb"></category><category term="node.js"></category></entry><entry><title>Web-чат polling на Node.JS</title><link href="/nodejs/web-chat-polling-na-nodejs/" rel="alternate"></link><updated>2011-04-10T21:49:00+04:00</updated><author><name>Admin</name></author><id>tag:,2011-04-10:nodejs/web-chat-polling-na-nodejs/</id><summary type="html">&lt;p&gt;&lt;img alt="чат" src="/media/2011/04/conversacion-150x150.png" title="чат" /&gt;&lt;/p&gt;
&lt;p&gt;Продолжим тему создания чата на Node.JS. На этот раз напишем чат,
который будет в качестве клиентов использовать браузеры.&lt;/p&gt;
&lt;h2 id="_1"&gt;Проблема&lt;/h2&gt;
&lt;p&gt;Т.к. протокол HTTP не позволяет устанавливать постоянное соединение
сервера с клиентом, то нам необходимо самостоятельно инициировать
соединение для считывания новых сообщений. Для этого существует
множество способов, но мы для начала воспользуемся самым примитивным -
polling. Данный способ представляет собой постоянное опрашивание сервера
через определённые интервалы времени. Сразу хочу уточнить, что данный
способ ОЧЕНЬ не оптимален с точки зрения использования ресурсов сервера
и сетевого канала, но для обучающих целей он вполне пригоден. В реальных
приложениях стоит использовать более продвинутые средства, которые я
постараюсь в скором времени рассмотреть в этом блоге. Итак, поехали!&lt;/p&gt;
&lt;h2 id="_2"&gt;Структура&lt;/h2&gt;
&lt;p&gt;Сначала рассмотрим структуру нашего приложения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Клиент&lt;/strong&gt; - скрипт на jquery, который выполняет следующие функции:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Отправка сообщения серверу&lt;/li&gt;
&lt;li&gt;Запрос у сервера данных о новых сообщениях и их отображение&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Сервер&lt;/strong&gt; - скрипт на Node.js. Выполняет следующие функции:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Добавляет присланные клиентами сообщения в массив сообщений&lt;/li&gt;
&lt;li&gt;Отдает клиентам новые сообщения&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;Реализация&lt;/h2&gt;
&lt;h3 id="_4"&gt;Клиентская часть&lt;/h3&gt;
&lt;p&gt;Для реализации клиентской части напишем небольшую страницу, которая
будет отвечать за визуализацию сообщений и их отправку. Весь код
приводить не буду, только интересные части:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
// ...
function load(){
    if ($(".message-row").size() == 0){
        var id = -1;
    }else{
        var id = $(".message-row:last").data('id');
    }

    $.getJSON('http://127.0.0.1:8124/?id=' + id + '&amp;amp;callback=?', function(data){
        data = $.parseJSON(data);
        for (i in data){
            if ($("#mess" + data[i]['id']).size() == 0){
                $('&amp;lt;div class="message-row" id="mess' + data[i]['id'] + '"&amp;gt;' + data[i]['message'] + '&amp;lt;/div&amp;gt;').appendTo("#chat-body");
                $(".message-row:last").data('id', data[i]['id']);
            }
        }
        $("#chat-body").animate({ scrollTop: $("#chat-body").attr("scrollHeight") }, 3000);
    });
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данная функция будет отвечать за получение новых сообщений от сервера и
их визуализацию. Каждое сообщение будет идентифицироваться уникальным id
которое равно порядковому номеру сообщения. При визуализации каждое
сообщение помещается в div и к нему прикрепляется id при помощи
&lt;a href="http://jqapi.com/#p=data"&gt;.data()&lt;/a&gt;. Затем перед тем как запросить новые сообщения мы получаем
id последнего сообщения и помещаем его в запрос. В случае если сообщений
до запроса не было - передаем магическое число -1.&lt;/p&gt;
&lt;p&gt;Т.к. наш сервер весит на специфическом порту, то для взаимодействия с
ним необходимо использовать cross domain ajax. Данный метод
подразумевает передачу последним параметром названия некой callback
функции. Генерацию этой функции берёт на себя jquery. Всё что нужно от
нас - это передать последним параметром в запросе ключ callback со
значением "?". Далее jquery заменит знак вопроса на название нашей
функции, которое он генерирует случайным образом. Всё что от нас
требовалось для реализации меж доменного ajax на стороне клиента мы
выполнили, особенности реализации на стороне сервера рассмотрим чуть
позже.&lt;/p&gt;
&lt;p&gt;Рассмотрим остальной код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
load();
setInterval(load, 2500);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Запускаем предварительную инициализацию списка сообщений и ставим
обработчик по таймеру, который будет вызываться каждые 2,5 секунды.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
// ....
$("#send-button").click(function(){
    if ($(".message-row").size() == 0){
        var id = -1;
    }else{
        var id = $(".message-row:last").data('id');
    }

    $.getJSON('http://127.0.0.1:8124/?message=' + $("input[name=message]").val() + '&amp;amp;username=' + $("input[name=nick]").val() + '&amp;amp;id=' + id + '&amp;amp;callback=?', function(data){
        data = $.parseJSON(data);
        for (i in data){
            $('&amp;lt;div class="message-row" id="mess' + data[i]['id'] + '"&amp;gt;' + data[i]['message'] + '&amp;lt;/div&amp;gt;').appendTo("#chat-body");
            $(".message-row:last").data('id', data[i]['id']);
        }
        $("#chat-body").animate({ scrollTop: $("#chat-body").attr("scrollHeight") }, 3000);
    });
    $("input[name=message]").val('');
});
// ....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ставим обработчик нажатия кнопки отправки сообщения. Здесь ничего
нового, просто такой же запрос как и в функции load за исключением того
что мы передаём дополнительные параметры - текст сообщения и псевдоним
пользователя.&lt;/p&gt;
&lt;h3 id="_5"&gt;Серверная часть&lt;/h3&gt;
&lt;p&gt;Тут начинается самое интересное :) Для реализации обмена по протоколу
HTTP в node.js есть одноименный модуль. Также мы будем использовать
модуль url для получения переданных нам параметров. Теперь рассмотрим
код, постараюсь как можно подробнее прокомментировать:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
// Подключение модулей
var http = require('http');
var url  = require('url');
// Массив сообщений
var messages = [];

// Создаем сервер и ставим обработчик запроса
http.createServer(function (request, response) { 
  // Получаем url
  var url_string = request.url;
  // Извлекаем параметры
  params = url.parse(url_string, true).query;

  // Если получено сообщение, то добавляем его в массив
  // предварительно объединив его с псевдонимом пользователя
  if (params.hasOwnProperty('message')){
      username = (params['username'].length == 0)?'guest':params['username'];
      message = params['message'];
      messages.push(username + ': ' + message);
  }

  // Извлекаем идентификатор сообщения
  var id = new Number(params['id']);
  var to, count, from = 0;
  // Получаем количество сообщений в массиве
  var len = messages.length;
  // Если пользователь только подключился,
  // то отдаём ему 10 последних сообщений
  if (id == -1){
      if (len &amp;lt; 10){
          count = len;
          from = 0;
      }else {
          count = 10;
          from = len - 10;
      }
  // Иначе отдаем те сообщения которые были получены после 
  // сообщения с переданным идентификатором
  }else{
      count = len - id - 1;
      from = id + 1;
  }
  to = from + count - 1;
  // Формируем результирующий массив сообщений
  ret_messages = [];
  for (i = from; i &amp;lt;= to; i++){
      ret_messages.push({message:messages[i], id:i});
  }

  // Кодируем массив в json
  body = JSON.stringify(ret_messages);
  // Устанавливаем заголовки ответа
  // Второй заголовок необходим для
  // cross domain ajax
  response.writeHead(200, {
    'Content-Type': 'application/json',
    "Access-Control-Allow-Origin": "*"
     });
  // Устанавливаем тело ответа и закрываем соединение
  // имитируем вызов метода
  response.end(params.callback + '(\'' + body + '\')'); 
// Вешаем сервер слушать 8124 порт на 127.0.0.1
}).listen(8124, "127.0.0.1"); 
console.log('Server running at http://127.0.0.1:8124/');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё достаточно прозрачно, кроме небольших заклинаний необходимых для
корректной работы cross domain ajax. Для того чтобы использовать чат в
сети поменяйте ip-адрес в 63 строке на свой внешний ip. Также не
забудьте поменять ip-адрес в клиенте.&lt;/p&gt;
&lt;p&gt;Здесь можете найти архив с полным кодом приложения - &lt;a href="stuff/web-chat-polling.zip"&gt;код&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Спасибо за внимание, подписывайтесь на RSS, все вопросы в комментарии
ниже!&lt;/p&gt;</summary><category term="cross domain ajax"></category><category term="java script"></category><category term="jquery"></category><category term="node.js"></category><category term="polling"></category></entry><entry><title>Node.JS + MySQL</title><link href="/nodejs/nodejs-mysql/" rel="alternate"></link><updated>2011-03-28T18:47:00+04:00</updated><author><name>Admin</name></author><id>tag:,2011-03-28:nodejs/nodejs-mysql/</id><summary type="html">&lt;p&gt;&lt;img alt="Mysql + Node.js" src="/media/2011/03/Mysql-300x76.png" title="Mysql + Node.js" /&gt;&lt;/p&gt;
&lt;p&gt;В последнем проекте появилась необходимость
организации работы Node.JS с MySQL. Для создания данного взаимодействия
существует несколько модулей, я решил использовать &lt;strong&gt;node-mysql&lt;/strong&gt;, т.к.
он предоставляет все необходимые мне функции.&lt;/p&gt;
&lt;h2 id="node-mysql"&gt;Установка node-mysql&lt;/h2&gt;
&lt;p&gt;Для установки воспользуемся git:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
cd ~/.node_libraries
git clone git://github.com/felixge/node-mysql.git mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого вы можете без проблем использовать данный модуль в вашей
работе.&lt;/p&gt;
&lt;h2 id="_1"&gt;Установка соединения&lt;/h2&gt;
&lt;p&gt;Перед началом выполнения запросов к БД необходимо выполнить подключение
к серверу MySQL. Рассмотрим как сделать это при помощи модуля node-mysql
в node.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var Client = require('mysql').Client,
client = new Client();
client.user = 'root';
client.password = 'password';
client.connect();
client.end();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первые две строки отвечают за подключение модуля и создания
объекта-клиента. Далее задаются параметры аутентификации и вызывается
метод connect. После этого если вы корректно указали пару логин-пароль,
то будет установлено соединение. Последняя строка соответственно
завершает соединение с сервером.&lt;/p&gt;
&lt;h3 id="_2"&gt;Отступление&lt;/h3&gt;
&lt;p&gt;Для того что-бы наш MySQL клиент мог передать данные аутентификации
необходимо чтобы node.js был скомпилирован с поддержкой ssl, иначе при
попытке установления соединения он будет жутко ругатся из-за то что не
сможет зашифровать пароль. Для корректной компиляции node.js с
поддержкой ssl в Debian вам потребуется пакет libssl-dev&lt;/p&gt;
&lt;h2 id="_3"&gt;Выполнение запросов&lt;/h2&gt;
&lt;p&gt;Сначала создадим тестовую базу данных и таблицу в ней:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sql
CREATE DATABASE  `test_nodejs` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
USE test_nodejs;
CREATE TABLE  `test_nodejs`.`test` (
`id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY ,
`some_text_data` VARCHAR( 255 ) NOT NULL ,
`some_date` DATE NOT NULL
) ENGINE = MYISAM ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь приступим непосредственно к выполнению запросов.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var Client = require('mysql').Client,
client = new Client();

client.user = 'root'; // Устанавливаем логин
client.password = 'password'; // Устанавливаем пароль
client.connect(); // Устанавливаем соединение
client.query('USE test_nodejs'); // Выполняем запрос на выбор БД
//  Запрос на вставку
client.query('INSERT INTO test VALUES (NULL, \'Test\', \'03-28-2011\')',function(){ 
    // Запрос на выборку
    client.query('SELECT * FROM test', function(error, result, fields){
        // Если возникла ошибка выбрасываем исключение
        if (error){
            throw error;
        }
        // выводим результат
        console.log(fields);
        console.log(result);
        // Завершаем соединение
        client.end();
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для тех кто уже достаточно освоился в асинхронном программировании
данный код не вызовет трудностей. Для выполнения запросов используется
метод клиента query, который кроме самого запроса принимает
callback-функцию с параметрами error (ошибка, если возникла), result
(массив объектов результата запроса), fields (описание полей из
множества полей результата). В результате выполнения вышеприведённого
кода получим:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::text
node test.js 
{ id: 
   { length: 45,
     received: 45,
     number: 2,
     type: 4,
     catalog: 'def',
     db: 'test_nodejs',
     table: 'test',
     originalTable: 'test',
     name: 'id',
     originalName: 'id',
     charsetNumber: 63,
     fieldLength: 20,
     fieldType: 8,
     flags: 16899,
     decimals: 0 },
  some_text_data: 
   { length: 69,
     received: 69,
     number: 3,
     type: 4,
     catalog: 'def',
     db: 'test_nodejs',
     table: 'test',
     originalTable: 'test',
     name: 'some_text_data',
     originalName: 'some_text_data',
     charsetNumber: 192,
     fieldLength: 765,
     fieldType: 253,
     flags: 4097,
     decimals: 0 },
  some_date: 
   { length: 59,
     received: 59,
     number: 4,
     type: 4,
     catalog: 'def',
     db: 'test_nodejs',
     table: 'test',
     originalTable: 'test',
     name: 'some_date',
     originalName: 'some_date',
     charsetNumber: 63,
     fieldLength: 10,
     fieldType: 10,
     flags: 4225,
     decimals: 0 } }
[ { id: 1,
    some_text_data: 'Test',
    some_date: Invalid Date } ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На этом всё. Если есть какие-либо вопросы по данной теме, задавайте их в
комментариях ниже, постараюсь ответить.&lt;/p&gt;</summary><category term="MySQL"></category><category term="node-mysql"></category><category term="node.js"></category></entry><entry><title>Простой сервер чата на Node.JS</title><link href="/nodejs/prostoi-server-chata-na-nodejs/" rel="alternate"></link><updated>2010-12-30T18:20:00+03:00</updated><author><name>Admin</name></author><id>tag:,2010-12-30:nodejs/prostoi-server-chata-na-nodejs/</id><summary type="html">&lt;p&gt;Здравствуйте! В продолжении темы Node.JS хочу рассмотреть пример
создания простого сервера чата на базе данной библиотеки.&lt;/p&gt;
&lt;p&gt;Во-первых нужно определится с функционалом. Наш сервер должен принимать
подключения от клиентов по протоколу tcp, открывать потоки и рассылать
всем клиентам полученные от каждого данные. Т.е. при получении данных от
одного из клиентов нужно записать их в каждый из поток остальных
клиентов.&lt;/p&gt;
&lt;p&gt;Для того что-бы реализовать сервер в ноде нам понадобится стандартный
модуль net. Подключим его добавив строку &lt;code&gt;var net = require('net');&lt;/code&gt; в
начало кода программы. Теперь мы можем обращаться ко всему функционалу
модуля через переменную net. В данном случае мы будем использовать метод
createServer который создает tcp сервер. В качестве параметров
передается функция, которая будет обрабатывать подключения к серверу.
При вызове в эту функцию передается один параметр - поток net.Stream,
созданного соединения. Данный поток является потоком ввода/вывода и
будет использоваться для непосредственного обмена данными с клиентом.
Итак, создаем сервер:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var server = net.createServer(function (c) {
    //Обрабатываем новое соединение
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сервер мы создали, но соединения он принимать не будет, т.к. мы не
назначили его на определённый ip:port или сокет. Для этого необходимо
воспользоваться методом &lt;code&gt;server.listen(port, [host], [callback])&lt;/code&gt;, если
хотим назначить сервер "слушать" порт или
&lt;code&gt;server.listen(path, [callback])&lt;/code&gt; для сокета. Назначим сервер "слушать"
10.32.3.23:8124:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
server.listen(8124, '10.32.3.23');
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Дальше для корректной работы нашего сервера необходимо описать
обработчики некоторых событий. Т.к. &lt;code&gt;net.Server&lt;/code&gt; и &lt;code&gt;net.Stream&lt;/code&gt; являются
EventEmitter, то они могут вызывать события. Рассмотрим нужные нам
события сервера:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;'connection'&lt;/em&gt; - &lt;code&gt;function (stream) {}&lt;/code&gt; - вызывается при подключении
нового клиента. Мы в данном примере будем использовать следующий
обработчик:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
function (c) {
    c.setEncoding('utf8'); //Устанавливаем кодировку
    streams.push(c);      //Добавляем поток в массив
    streams.forEach(function(stream){ //Обходим все сохраненные потоки
        stream.write(c.remoteAddress + ' - is connected\n', 'utf8'); //Выводим сообщение о новом клиенте
    });
    c.on('data', onStreamData); //Добавляем обработчик события 'data' нового потока
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;net.Stream.remote Address - ip адрес клиента подключенного к данному
потоку.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;'close'&lt;/em&gt; - &lt;code&gt;function () {}&lt;/code&gt; - вызывается при закрытии сервера. Наш
обработчик:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
function(){
    streams.forEach(function(stream){ //Обходим все сохраненные потоки
        stream.write('Server is going down! Bye-bye!','utf8'); //Выводим сообщение
        stream.destroy(); //Уничтожаем поток
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хочу обратить внимание, что в данном участке кода нет непосредственного
завершения процесса, но он приводит к этому. Связанно это с тем что
программы на node работают пока есть активные обработчики, а после
выполнения этого кода все обработчики назначенные потокам будут
отключены и это приведет к завершению процесса.&lt;/p&gt;
&lt;p&gt;Теперь рассмотрим события потока:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;'data'&lt;/em&gt; - &lt;code&gt;function (data) {}&lt;/code&gt; - вызывается при получении данных от
клиента. data - буфер, но если до этого вызван метод setEncoding, то
data - строка в заданной кодировке. Рассмотрим наш обработчик:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
function onStreamData(data){
    // Обработка команды завершения работы сервера
    if (0 === data.indexOf('.down')){
        server.close(); // Приводит к тому, что сервер больше не принимает соединения, а также вызывает событие 'close'
        return ;
    }
    // Заносим в переменную текущий поток
    var current_stream = this;
    streams.forEach(function(stream){
        if (stream != current_stream) //Если поток не является текущим потоком, то выводим полученные данные
            stream.write(current_stream.remoteAddress + ':' + data, 'utf8');
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь полный код программы:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var net = require('net');
var streams = Array();

function onStreamData(data){
    if (0 === data.indexOf('.down')){
        server.close();
        return ;
    }
    var current_stream = this;
    streams.forEach(function(stream){
        if (stream != current_stream)
            stream.write(current_stream.remoteAddress + ':' + data, 'utf8');
    });
}

var server = net.createServer(function (c) {
    c.setEncoding('utf8');
    streams.push(c);
    streams.forEach(function(stream){
        stream.write(c.remoteAddress + ' - is connected\n', 'utf8');
    });
    c.on('data', onStreamData);
});

server.on('close', function(){
    streams.forEach(function(stream){
        stream.write('Server is going down! Bye-bye!','utf8');
        stream.destroy();
    });
});

server.maxConnections = 2; // Максимальное кол-во подключений
server.listen(8124, '10.32.3.23'); // Задайте свой внешний ip или localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сохраните код в файле, например server.js. Теперь можно запустить сервер
и проверить его в действии. Для запуска выполните:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для того что-бы подключится воспользуемся telnet:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
telnet 10.32.3.23 8124
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Не забудьте поменять ip и порт на тот, который вы использовали при
вызове метода listen.&lt;/p&gt;
&lt;p&gt;При желании можете расширить пример, дописать назначение псевдонимов
клиентам или добавить специальные команды(такие как .down) для бана или
выкидывания пользователей из чата.&lt;/p&gt;
&lt;p&gt;Как вы смогли убедится Node.JS предоставляет весь необходимый функционал
для создания сетевых приложений. В скором времени постараюсь продолжить
тему разработки приложений на Node.JS новыми и интересными примерами.
Спасибо за внимание :)&lt;/p&gt;</summary><category term="java script"></category><category term="node.js"></category></entry><entry><title>Node.JS - введение</title><link href="/nodejs/nodejs-vvedenie/" rel="alternate"></link><updated>2010-12-22T11:33:00+03:00</updated><author><name>Admin</name></author><id>tag:,2010-12-22:nodejs/nodejs-vvedenie/</id><summary type="html">&lt;p&gt;&lt;img alt="image" src="/media/2010/12/media_httpnodeblogfil_occie.png.scaled500.png" title="nodejs" /&gt;&lt;/p&gt;
&lt;p&gt;Сегодня я хочу рассмотреть библиотеку для асинхронного программирования
server-side приложений на Java Script - Node.JS.&lt;/p&gt;
&lt;p&gt;Работает библиотека на Java Script движке V8 от самого гугла и
предоставляет базовые возможности для создания масштабируемых сетевых
приложений. Изначально Node заточен под высокие нагрузки, так что если
вы разрабатываете очередной facebook, то задумайтесь об использовании
server-side JS в своем приложении. Основная фишка библиотеки в работе с
HTTP протоколом, т.е. для нас web-разработчиков, то что доктор прописал.&lt;/p&gt;
&lt;h2 id="_1"&gt;Установка&lt;/h2&gt;
&lt;p&gt;Я рассмотрю процесс установки в ОС Linux (Debian 5.0). Сначала скачиваем
архив с исходниками &lt;a href="http://nodejs.org/#download"&gt;здесь&lt;/a&gt;. Т.к. всё необходимое для работы
библиотеки включено в дистрибутив, то установка очень простая и знакома
всем линуксоидам, которые когда-либо собирали что-нибудь из исходников.
Итак, распаковываем архив, затем переходим в директорию с исходниками и
выполняем:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
./configure#make#make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого можно проверить корректность установки, для этого
выполните:&lt;code&gt;make test&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="hello-world"&gt;Hello world&lt;/h2&gt;
&lt;p&gt;Теперь напишем простой пример web-сервера, который отвечает "Hello
World" на каждый запрос:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::javascript
var http = require('http'); //Подключаем модуль http
http.createServer(function (req, res) { //Создаем сервер и устанавливаем обработчик на подключение
  res.writeHead(200, {'Content-Type': 'text/plain'}); //Устанавливаем заголовок
  res.end('Hello World\n'); // Вывод сообщения и завершение вывода
}).listen(8124, "127.0.0.1"); // Заставляем сервер "слушать" 127.0.0.1:8124
console.log('Server running at http://127.0.0.1:8124/'); //Выводим сообщение в консоль
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для запуска нашего сервера выполняем:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
node example.jsServer running at http://127.0.0.1:8124/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Что-бы проверить, что всё работает открываем в браузере
http://127.0.0.1:8124 и получаем "Hello World" в ответ.&lt;/p&gt;
&lt;p&gt;Таким способом мы получаем работающий web-сервер в несколько строк кода.
В скором времени будут ещё топики на тему Node.JS, в которых мы
подробнее рассмотрим процесс написания server-side JS приложений.&lt;/p&gt;
&lt;h2 id="_2"&gt;Ссылки&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://nodejs.org/"&gt;nodejs.org&lt;/a&gt; - оф.сайт. Документация, новости проекта, примеры
приложений.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://nodejs.ru"&gt;nodejs.ru&lt;/a&gt; - русскоязычный блог о Node.js&lt;/p&gt;</summary><category term="java script"></category><category term="node.js"></category></entry></feed>