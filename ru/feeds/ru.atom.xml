<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Tech blog by @dizballanze - ru</title><link href="/ru/" rel="alternate"></link><link href="http://dizballanze.com/feeds/ru.atom.xml" rel="self"></link><id>/ru/</id><updated>2017-06-21T15:08:00+03:00</updated><entry><title>Middleware для обеспечения безопасности в Django</title><link href="/ru/django-security-middleware/" rel="alternate"></link><published>2017-06-21T15:08:00+03:00</published><updated>2017-06-21T15:08:00+03:00</updated><author><name>Admin</name></author><id>tag:None,2017-06-21:/ru/django-security-middleware/</id><summary type="html">&lt;p&gt;Django предоставляет защитные механизмы от различных атак, но не все они включены по-умолчанию. В этом посте
я хочу рассмотреть какие возможности по защите предоставляет Django и как их использовать.&lt;/p&gt;
&lt;h1 id="djangomiddlewaresecuritysecuritymiddleware"&gt;django.middleware.security.SecurityMiddleware&lt;/h1&gt;
&lt;p&gt;Этот middleware включен по-умолчанию и должен быть самым первым в списке, для того чтобы злонамеренные запросы
блокировались …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Django предоставляет защитные механизмы от различных атак, но не все они включены по-умолчанию. В этом посте
я хочу рассмотреть какие возможности по защите предоставляет Django и как их использовать.&lt;/p&gt;
&lt;h1 id="djangomiddlewaresecuritysecuritymiddleware"&gt;django.middleware.security.SecurityMiddleware&lt;/h1&gt;
&lt;p&gt;Этот middleware включен по-умолчанию и должен быть самым первым в списке, для того чтобы злонамеренные запросы
блокировались до обработки другими middleware.&lt;/p&gt;
&lt;p&gt;Он защищает сразу от многих атак и каждую из этих защит можно включить/отключить отдельно используя переменные в
&lt;code&gt;settings.py&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECURE_BROWSER_XSS_FILTER&lt;/code&gt; - по-умолчанию отключен, при включении добавляет заголовок &lt;code&gt;x-xss-protection:1; mode=block&lt;/code&gt;,
заставляющий, поддерживающие этот заголовок браузеры, блокировать потенциально опасные запросы содержащие javascript 
код в POST или GET параметрах.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_CONTENT_TYPE_NOSNIFF&lt;/code&gt; - по-умолчанию отключен, при включении добавляет заголовок
&lt;code&gt;x-content-type-options:nosniff&lt;/code&gt;, запрещающий браузерам угадывать Content-Type ответа сервера, что блокирует возможность
неправильно интерпретировать загруженные пользователем файлы. Если у вас загруженные файлы отдаются напрямую
web-сервером (например, Nginx, см. ниже), то также нужно настроить чтобы сервер отдавал этот заголовок.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nginx
server {
    # ...
    location /media/ {
        # ...
        add_header X-Content-Type-Options nosniff;
    }
}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECURE_HSTS_SECONDS&lt;/code&gt; по-умолчанию отключен, добавляет заголовок &lt;code&gt;Strict-Transport-Security&lt;/code&gt;, который запрещает браузерам открывать сайт по
нешифрованному HTTP на заданное количество секунд. Заголовок действует на весь домен, по-этому его можно включать, только если весь контент
отдается по HTTPS. Этот заголовок позволяется защититься от некоторых man-in-the-middle атак.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_HSTS_PRELOAD&lt;/code&gt; - по-умолчанию отключен, нужно включить при добавлении сайта в
&lt;a href="https://hstspreload.org/"&gt;захардкоженный список&lt;/a&gt; &lt;code&gt;HTTPS-only&lt;/code&gt; сайтов, который поставляется вместе с Google Chrome.
Будет работать только если задан параметр &lt;code&gt;SECURE_HSTS_SECONDS&lt;/code&gt; &amp;gt; 0.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_HSTS_INCLUDE_SUBDOMAINS&lt;/code&gt; - по-умолчанию отключен, при включении запрещает браузерам открывать по нешифрованному
HTTP также и все поддомены сайта.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_SSL_REDIRECT&lt;/code&gt; - по-умолчанию отключен, при включении редиректит все HTTP запросы на HTTPS. Вероятно вам
захочется делать этот редирект средствами web-сервера (например, Nginx):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nginx
server {
    listen 80;
    server_name  example.org;
    rewrite ^ http://example.org$request_uri? permanent;
}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECURE_REDIRECT_EXEMPT&lt;/code&gt; - по-умолчанию пустой список. URL адреса, соответствующие заданным в списке регулярным
выражениям, не будут перенаправляться с HTTP на HTTPS, при включении &lt;code&gt;SECURE_SSL_REDIRECT&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_SSL_HOST&lt;/code&gt; - по-умолчанию не задан. Если задать строку (домен), то при включенном &lt;code&gt;SECURE_SSL_REDIRECT&lt;/code&gt; все
запросы будут перенаправляться на этот домен.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Если при включении HSTS настроек заголовки не добавляются, возможно Django не распознает, что запросы зашифрованные
из-за того, что располагается за реверс-прокси. Для того, чтобы Django понимал какие запросы были зашифрованными нужно
добавить параметр &lt;code&gt;SECURE_PROXY_SSL_HEADER&lt;/code&gt; в &lt;code&gt;settings.py&lt;/code&gt;, который содержит кортеж &lt;code&gt;("header-name", "header-value")&lt;/code&gt;.
Получив такой заголовок от прокси сервера Django будет считать что запрос был получен по протоколу HTTPS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="djangomiddlewarecsrfcsrfviewmiddleware"&gt;django.middleware.csrf.CsrfViewMiddleware&lt;/h2&gt;
&lt;p&gt;Middleware защищает от &lt;a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0"&gt;межсайтовой подделки запроса&lt;/a&gt;.
При отправке любых небезопасных (POST, PUT, DELETE) запросов middleware будет проверять наличие csrf токена и если
этот токен не найден или не корректен запрос будет фильтроваться. Для отправки токена существуют разные способы.
Для обычных форм можно добавлять скрытое поле используя тег &lt;code&gt;{% csrf_token %}&lt;/code&gt; в форме. Для ajax запросов можно
добавлять заголовок &lt;code&gt;X-CSRFToken&lt;/code&gt; со значением &lt;a href="https://docs.djangoproject.com/en/1.11/ref/csrf/#ajax"&gt;полученным из cookie&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Если у вас SPA и вы не используете &lt;code&gt;{% csrf_token %}&lt;/code&gt;, то вам нужно заставить Django выдать клиенту cookie с токеном.
Для этого можно использовать view decorator &lt;a href="https://docs.djangoproject.com/en/1.11/ref/csrf/#django.views.decorators.csrf.ensure_csrf_cookie"&gt;ensure_csrf_cookie&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="djangomiddlewareclickjackingxframeoptionsmiddleware"&gt;django.middleware.clickjacking.XFrameOptionsMiddleware&lt;/h2&gt;
&lt;p&gt;При включении данный middleware добавляет заголовок &lt;code&gt;X-Frame-Options: SAMEORIGIN&lt;/code&gt;, который запрещает современным браузерам
загружать сайт в (i)frame на сайтах с другим доменом. Также можно запретить подключение сайта со всех доменов используя
переменную &lt;code&gt;X_FRAME_OPTIONS = 'DENY'&lt;/code&gt;.&lt;/p&gt;</content></entry></feed>