<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Tech blog by @dizballanze - ru</title><link href="/ru/" rel="alternate"></link><link href="http://dizballanze.com/feeds/ru.atom.xml" rel="self"></link><id>/ru/</id><updated>2018-04-29T12:28:00+03:00</updated><entry><title>Обращайте внимание на отчет о покрытии кода тестами</title><link href="/ru/test-coverage-report-in-use/" rel="alternate"></link><published>2018-04-29T12:28:00+03:00</published><updated>2018-04-29T12:28:00+03:00</updated><author><name>Admin</name></author><id>tag:None,2018-04-29:/ru/test-coverage-report-in-use/</id><summary type="html">&lt;p&gt;Если вы читаете этот пост, вы скорее всего, пишите юнит-тесты (и правильно делаете). Также с большой вероятностью
вы знаете о метрике &lt;strong&gt;покрытие кода&lt;/strong&gt;, которая показывает какой код был выполнен в процессе тестирования.
Но так ли часто вы заглядываете в отчет о покрытии кода? Если ответ отрицательный, то этот пост для …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Если вы читаете этот пост, вы скорее всего, пишите юнит-тесты (и правильно делаете). Также с большой вероятностью
вы знаете о метрике &lt;strong&gt;покрытие кода&lt;/strong&gt;, которая показывает какой код был выполнен в процессе тестирования.
Но так ли часто вы заглядываете в отчет о покрытии кода? Если ответ отрицательный, то этот пост для вас.
Я постараюсь показать, как отчет о покрытии кода открывает для разработчика множество интересных и
полезных данных, в конечном счете позволяющих улучшить качество кода.&lt;/p&gt;
&lt;h2 id="testirovanie"&gt;Тестирование&lt;/h2&gt;
&lt;h3 id="kod-bez-testov"&gt;Код без тестов&lt;/h3&gt;
&lt;p&gt;Самой очевидной пользой от отчета о покрытии кода является возможность определить какой код не тестируется.
Часто это означает, что вам нужно добавить тест(ы) для этого кода, чтобы убедиться, что он работает так, как ожидается
и что не менее важно, что он продолжит корректно работать при дальнейшей развитии приложения.&lt;/p&gt;
&lt;p&gt;Сейчас вам может показаться, что тот или иной участок кода слишком простой и ошибок в нем быть не может, соответственно
можно не тратить время на написание тестов к нему. В такие моменты важно не забывать, что код меняется и каждое
изменение может привести к &lt;a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"&gt;регрессии&lt;/a&gt;
и написанный заранее тест, может сберечь часы потраченные на дебаг.&lt;/p&gt;
&lt;h3 id="bag-pri-kotorom-ispolniaetsia-ne-ozhidaemyi-kod"&gt;Баг при котором исполняется не ожидаемый код&lt;/h3&gt;
&lt;p&gt;Более редкий кейс, когда тест проходит, но отчет о покрытии кода показывает, что код, который ожидается, что будет
выполнен, на самом деле не выполняется.&lt;/p&gt;
&lt;p&gt;Это может быть из-за бага в тесте, вместо нужного метода вызывается другой, который возвращает такой же результат.
Такая ошибка вызывает уверенность в том, что код работает и регрессии отслеживаются, хотя это не так.
В итоге это может привести к попаданию багов на продакшн с вытекающими последствиями, а также к длительному
процессу поиска ошибки.&lt;/p&gt;
&lt;p&gt;Такой же результат может быть из-за бага в коде, например, роутинг веб-приложения настроен неправильно и запрос
отправляется на другой метод, который по случайности возвращает ожидаемый результат. Это приводит к попаданию
неработающего кода на продакшн и найти ошибку в таком случае довольно сложно, если опираться только на тесты.&lt;/p&gt;
&lt;p&gt;Изучая отчет о покрытии кода перед отправкой изменений в репозиторий, позволяет достаточно быстро находить такие ошибки
и исправлять их прежде чем они нанесут ущерб, не говоря уже об экономии времени.&lt;/p&gt;
&lt;h2 id="mertvyi-kod_1"&gt;Мертвый код&lt;/h2&gt;
&lt;h3 id="staryi-kod-kotoryi-uzhe-nigde-ne-ispolzuetsia"&gt;Старый код, который уже нигде не используется&lt;/h3&gt;
&lt;p&gt;В некоторых случаях, отчет о покрытии может помочь выявить код, который уже нигде не используется. Например, приватные
методы, которые больше нигде не вызываются, в том числе в тестах, т.к. тестировать нужно только публичный интерфейс.&lt;/p&gt;
&lt;p&gt;Нет ничего приятного в трате времени на изучение кода, который в итоге оказывается мертвым. Такой код следует сразу же
удалять, чтобы он не мешал дальнейшей поддержке приложения. Если вам кажется, что этот код может когда-то пригодиться -
все равно удалите его, если он не нужен прямо сейчас. При необходимости достать этот код из системы контроля версий
не составит труда.&lt;/p&gt;
&lt;h3 id="mertvyi-kod-v-testakh"&gt;Мертвый код в тестах&lt;/h3&gt;
&lt;p&gt;Еще один более хитрый пример мертвого кода - мертвый код в тестах. В цикле вы проходите по списку объектов и
выполняете проверки на каждом из них. Если список по какой-то причине оказывается пустым - тест проходит, хотя
ни одной проверки выполнено не было. Такие ошибки также легко найти при помощи отчета о покрытии кода, т.к. тело
цикла будет показано как не покрытый код.&lt;/p&gt;
&lt;h2 id="zakliuchenie_1"&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Отчет о покрытии кода является очень важным инструментом в руках разработчика. После каждого изменения нужно смотреть
как изменится отчет. В идеале, это должно происходить автоматически и входить в CI pipeline. Если количество не
покрытых строк увеличилось - билд должен падать или по крайней мере должно отправляться предупреждение об этом.
Это позволит избежать ряда ошибок и в целом поддерживать код в более здоровом состоянии.&lt;/p&gt;</content></entry><entry><title>Middleware для обеспечения безопасности в Django</title><link href="/ru/django-security-middleware/" rel="alternate"></link><published>2017-06-21T15:08:00+03:00</published><updated>2017-06-21T15:08:00+03:00</updated><author><name>Admin</name></author><id>tag:None,2017-06-21:/ru/django-security-middleware/</id><summary type="html">&lt;p&gt;Django предоставляет защитные механизмы от различных атак, но не все они включены по-умолчанию. В этом посте
я хочу рассмотреть какие возможности по защите предоставляет Django и как их использовать.&lt;/p&gt;
&lt;h1 id="djangomiddlewaresecuritysecuritymiddleware"&gt;django.middleware.security.SecurityMiddleware&lt;/h1&gt;
&lt;p&gt;Этот middleware включен по-умолчанию и должен быть самым первым в списке, для того чтобы злонамеренные запросы
блокировались …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Django предоставляет защитные механизмы от различных атак, но не все они включены по-умолчанию. В этом посте
я хочу рассмотреть какие возможности по защите предоставляет Django и как их использовать.&lt;/p&gt;
&lt;h1 id="djangomiddlewaresecuritysecuritymiddleware"&gt;django.middleware.security.SecurityMiddleware&lt;/h1&gt;
&lt;p&gt;Этот middleware включен по-умолчанию и должен быть самым первым в списке, для того чтобы злонамеренные запросы
блокировались до обработки другими middleware.&lt;/p&gt;
&lt;p&gt;Он защищает сразу от многих атак и каждую из этих защит можно включить/отключить отдельно используя переменные в
&lt;code&gt;settings.py&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECURE_BROWSER_XSS_FILTER&lt;/code&gt; - по-умолчанию отключен, при включении добавляет заголовок &lt;code&gt;x-xss-protection:1; mode=block&lt;/code&gt;,
заставляющий, поддерживающие этот заголовок браузеры, блокировать потенциально опасные запросы содержащие javascript 
код в POST или GET параметрах.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_CONTENT_TYPE_NOSNIFF&lt;/code&gt; - по-умолчанию отключен, при включении добавляет заголовок
&lt;code&gt;x-content-type-options:nosniff&lt;/code&gt;, запрещающий браузерам угадывать Content-Type ответа сервера, что блокирует возможность
неправильно интерпретировать загруженные пользователем файлы. Если у вас загруженные файлы отдаются напрямую
web-сервером (например, Nginx, см. ниже), то также нужно настроить чтобы сервер отдавал этот заголовок.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;# ...&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/media/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;# ...&lt;/span&gt;
        &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;X-Content-Type-Options&lt;/span&gt; &lt;span class="s"&gt;nosniff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECURE_HSTS_SECONDS&lt;/code&gt; по-умолчанию отключен, добавляет заголовок &lt;code&gt;Strict-Transport-Security&lt;/code&gt;, который запрещает браузерам открывать сайт по
нешифрованному HTTP на заданное количество секунд. Заголовок действует на весь домен, по-этому его можно включать, только если весь контент
отдается по HTTPS. Этот заголовок позволяется защититься от некоторых man-in-the-middle атак.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_HSTS_PRELOAD&lt;/code&gt; - по-умолчанию отключен, нужно включить при добавлении сайта в
&lt;a href="https://hstspreload.org/"&gt;захардкоженный список&lt;/a&gt; &lt;code&gt;HTTPS-only&lt;/code&gt; сайтов, который поставляется вместе с Google Chrome.
Будет работать только если задан параметр &lt;code&gt;SECURE_HSTS_SECONDS&lt;/code&gt; &amp;gt; 0.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_HSTS_INCLUDE_SUBDOMAINS&lt;/code&gt; - по-умолчанию отключен, при включении запрещает браузерам открывать по нешифрованному
HTTP также и все поддомены сайта.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_SSL_REDIRECT&lt;/code&gt; - по-умолчанию отключен, при включении редиректит все HTTP запросы на HTTPS. Вероятно вам
захочется делать этот редирект средствами web-сервера (например, Nginx):&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt;  &lt;span class="s"&gt;example.org&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;rewrite&lt;/span&gt; &lt;span class="s"&gt;^&lt;/span&gt; &lt;span class="s"&gt;http://example.org&lt;/span&gt;&lt;span class="nv"&gt;$request_uri?&lt;/span&gt; &lt;span class="s"&gt;permanent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECURE_REDIRECT_EXEMPT&lt;/code&gt; - по-умолчанию пустой список. URL адреса, соответствующие заданным в списке регулярным
выражениям, не будут перенаправляться с HTTP на HTTPS, при включении &lt;code&gt;SECURE_SSL_REDIRECT&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURE_SSL_HOST&lt;/code&gt; - по-умолчанию не задан. Если задать строку (домен), то при включенном &lt;code&gt;SECURE_SSL_REDIRECT&lt;/code&gt; все
запросы будут перенаправляться на этот домен.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Если при включении HSTS настроек заголовки не добавляются, возможно Django не распознает, что запросы зашифрованные
из-за того, что располагается за реверс-прокси. Для того, чтобы Django понимал какие запросы были зашифрованными нужно
добавить параметр &lt;code&gt;SECURE_PROXY_SSL_HEADER&lt;/code&gt; в &lt;code&gt;settings.py&lt;/code&gt;, который содержит кортеж &lt;code&gt;("header-name", "header-value")&lt;/code&gt;.
Получив такой заголовок от прокси сервера Django будет считать что запрос был получен по протоколу HTTPS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="djangomiddlewarecsrfcsrfviewmiddleware"&gt;django.middleware.csrf.CsrfViewMiddleware&lt;/h2&gt;
&lt;p&gt;Middleware защищает от &lt;a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0"&gt;межсайтовой подделки запроса&lt;/a&gt;.
При отправке любых небезопасных (POST, PUT, DELETE) запросов middleware будет проверять наличие csrf токена и если
этот токен не найден или не корректен запрос будет фильтроваться. Для отправки токена существуют разные способы.
Для обычных форм можно добавлять скрытое поле используя тег &lt;code&gt;{% csrf_token %}&lt;/code&gt; в форме. Для ajax запросов можно
добавлять заголовок &lt;code&gt;X-CSRFToken&lt;/code&gt; со значением &lt;a href="https://docs.djangoproject.com/en/1.11/ref/csrf/#ajax"&gt;полученным из cookie&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Если у вас SPA и вы не используете &lt;code&gt;{% csrf_token %}&lt;/code&gt;, то вам нужно заставить Django выдать клиенту cookie с токеном.
Для этого можно использовать view decorator &lt;a href="https://docs.djangoproject.com/en/1.11/ref/csrf/#django.views.decorators.csrf.ensure_csrf_cookie"&gt;ensure_csrf_cookie&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="djangomiddlewareclickjackingxframeoptionsmiddleware"&gt;django.middleware.clickjacking.XFrameOptionsMiddleware&lt;/h2&gt;
&lt;p&gt;При включении данный middleware добавляет заголовок &lt;code&gt;X-Frame-Options: SAMEORIGIN&lt;/code&gt;, который запрещает современным браузерам
загружать сайт в (i)frame на сайтах с другим доменом. Также можно запретить подключение сайта со всех доменов используя
переменную &lt;code&gt;X_FRAME_OPTIONS = 'DENY'&lt;/code&gt;.&lt;/p&gt;</content></entry></feed>