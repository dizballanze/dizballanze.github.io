<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="HandheldFriendly" content="true">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Оптимизация производительности Django проектов (часть 1)</title>
    <link rel="stylesheet" href="/theme/css/native.css" />
    <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif&amp;subset=cyrillic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=PT+Mono&amp;subset=cyrillic" rel="stylesheet">
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-20497524-1', 'auto');
      ga('send', 'pageview');
    </script>
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
  styles: {
  ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
  },
  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']],processEscapes: true}
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body id="index" class="home">
        <header id="banner" class="body">
            <h1><a href="/ru/">Tech blog by @dizballanze <strong></strong></a></h1>
            <div id="langs">
                <a href="/">En</a>
                <a href="/ru/">Ru</a>
            </div>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/ru/about-me/">Автор</a></li>
            <li><a href="https://wbtech.pro/">WB–Tech</a></li>
            <li><a href="https://debugmail.io/">DebugMail</a></li>
        </ul>
        </nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/ru/django-project-optimization-part-1/" rel="bookmark"
         title="Permalink to Оптимизация производительности Django проектов (часть 1)">Оптимизация производительности Django проектов (часть 1)</a></h2>
    <time class="published" datetime="2017-06-14T16:47:00+03:00"><nobr>14 июн 2017</nobr></time>
  </header>
  <div class="entry-content">
    <p>Django это мощный фреймворк используемый в множестве отличных проектов. Из коробки в нем включено много полезных
батареек, которые значительно ускоряют разработку и соответственно уменьшают ее стоимость. Однако, когда проект
растет и набирает аудиторию, вы неизбежно столкнетесь с проблемами производительности. В этом посте я попробую
рассказать о том с какими проблемами вы можете столкнуться и как их решить.</p>
<p>Это первая статья из серии, здесь будут рассмотрено профилирование и настройки Django.</p>
<h2 id="profilirovanie">Профилирование</h2>
<p>Перед тем выполнять оптимизацию необходимо измерить текущую производительность, чтобы после оптимизации можно было сравнить
результаты. Такие измерения нужно будет делать часто, после каждого изменения, так что процесс должен быть автоматизированным.</p>
<p>Профилирование - это процесс измерения метрик проекта. Таких как: время ответа сервера, использование CPU,
использование памяти и тд. Python предоставляет <a href="https://docs.python.org/3/library/profile.html">профайлер</a> в стандартной
библиотеке, который вполне удобно использовать для измерения производительности кусков кода.
Но для профилирования целового проекта существуют более удобные решения.</p>
<h3 id="logirovanie">Логирование</h3>
<p>Самая частая проблема производительности это лишние и/или не эффективные запросы к БД. Можно настроить логирование,
для просмотра всех SQL запросов, которые выполняются в процессе обработки запроса. Добавьте в <code>settings.py</code>:</p>
<p><code>python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'level': 'DEBUG',
            'handlers': ['console'],
        }
    },
}</code></p>
<p>Убедитесь, что <code>DEBUG = True</code> и перезагрузите сервер. Теперь в консоли должны выводится все SQL запросы и длительность
выполнения каждого из них.</p>
<p><code>sql
(0.002) SELECT DISTINCT "handbooks_size"."size_type_id", "goods_goods"."size_id" FROM "goods_goods" LEFT OUTER JOIN "handbooks_size" ON ("goods_goods"."size_id" = "handbooks_size"."id") WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') ORDER BY "goods_goods"."size_id" ASC; args=('reserved', 'sold', 'approved')
(0.001) SELECT DISTINCT "goods_goods"."color_id" FROM "goods_goods" WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') ORDER BY "goods_goods"."color_id" ASC; args=('reserved', 'sold', 'approved')
(0.001) SELECT DISTINCT "handbooks_size"."row", "handbooks_size"."size_type_id", "goods_goods"."size_id" FROM "goods_goods" LEFT OUTER JOIN "handbooks_size" ON ("goods_goods"."size_id" = "handbooks_size"."id") WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') ORDER BY "goods_goods"."size_id" ASC; args=('reserved', 'sold', 'approved')
(0.000) SELECT DISTINCT "goods_goods"."season" FROM "goods_goods" WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') ORDER BY "goods_goods"."season" ASC; args=('reserved', 'sold', 'approved')
(0.000) SELECT DISTINCT "goods_goods"."state" FROM "goods_goods" WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') ORDER BY "goods_goods"."state" ASC; args=('reserved', 'sold', 'approved')
(0.002) SELECT MAX("__col1"), MIN("__col2") FROM (SELECT "goods_goods"."id" AS Col1, CASE WHEN "goods_goods"."status" = 'sold' THEN 1 ELSE 0 END AS "x_order", "goods_goods"."price_sell" AS "__col1", "goods_goods"."price_sell" AS "__col2" FROM "goods_goods" WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') GROUP BY "goods_goods"."id", CASE WHEN "goods_goods"."status" = 'sold' THEN 1 ELSE 0 END) subquery; args=('sold', 1, 0, 'reserved', 'sold', 'approved', 'sold', 1, 0)
(0.001) SELECT COUNT(*) FROM (SELECT "goods_goods"."id" AS Col1, CASE WHEN "goods_goods"."status" = 'sold' THEN 1 ELSE 0 END AS "x_order" FROM "goods_goods" WHERE "goods_goods"."status" IN ('reserved', 'sold', 'approved') GROUP BY "goods_goods"."id", CASE WHEN "goods_goods"."status" = 'sold' THEN 1 ELSE 0 END) subquery; args=('sold', 1, 0, 'reserved', 'sold', 'approved', 'sold', 1, 0)
[15/Jun/2017 11:03:49] "GET /goods HTTP/1.0" 200 32583</code></p>
<h3 id="django-debug-toolbar">Django Debug Toolbar</h3>
<p><a href="http://django-debug-toolbar.readthedocs.io/en/stable/">Это</a> Django приложение, которые предоставляет набор панелей,
некоторые из которых удобно использовать для профилирование. По умолчанию включена SQL панель, которая предоставляет
даже больше информации чем стандартное логирование Django. Некоторые дополнительные возможности: временная диаграмма
запросов, traceback, просмотр результатов и <code>EXPLAIN</code> каждого запроса.</p>
<p><img alt="DDT" src="/media/2017/6/ddt.png"/></p>
<p>DDT также поставляется с отключенной по умолчанию панелью для профилирования. Эта панель отображает результаты профилирования
в удобном web-интерфейсе. Для включения панели добавьте <code>debug_toolbar.panels.profiling.ProfilingPanel</code> в
список <code>DEBUG_TOOLBAR_PANELS</code> в <code>settings.py</code>.</p>
<p><img alt="DDT profiling panel" src="/media/2017/6/ddt-profiling-panel.png"/></p>
<h3 id="silk">Silk</h3>
<p>Еще один отличный пакет, который особенно пригодится если у вас API и соответственно DDT нельзя использовать.
Как установить и настроить пакет можно посмотреть на <a href="https://github.com/django-silk/silk#installation">github проекта</a>.</p>
<p><img alt="silky-screenshot.png" src="/media/2017/6/silky-screenshot.png"/></p>
<p>После установки и настройки перезагрузите сервер и перейдите по URL: <code>/silk/</code>. По этому адресу должен быть доступен
web-интерфейс, который показывает:</p>
<ul>
<li>Статистику по запросам (в разрезе метод/URL с возможностью просмотра отдельных запросов),</li>
<li>просмотр SQL запросов,</li>
<li>просмотр результатов профилирования.</li>
</ul>
<p>Профайлер можно включить для всего проекта установив <code>SILKY_PYTHON_PROFILER = True</code> в <code>settings.py</code>. Или использовать
только в определенных местах, заключив профилируемый код в декоратор или контекст процессор:</p>
<p>```python
from silk.profiling.profiler import silk_profile</p>
<p>@silk_profile(name='View Blog Post')
def post(request, post_id):
    p = Post.objects.get(pk=post_id)
    return render_to_response('post.html', {
        'post': p
    })</p>
<p>def post(request, post_id):
    with silk_profile(name='View Blog Post #%d' % self.pk):
        p = Post.objects.get(pk=post_id)
        return render_to_response('post.html', {
            'post': p
        })
```</p>
<h3 id="testovye-dannye">Тестовые данные</h3>
<p>Очень важно использовать для профилирования данные похожие на те, что используются в production. В идеале нужно взять бекап
с production сервера, развернуть его на локальной машине и использовать эти данные для профилирования проекта. Если вы
попробуете профилировать проект на пустой/маленькой базе данных, вероятно, вы получите некорректный результат, который
не будет соответствовать реальным проблемам на боевом окружении, что не поможет выполнить нужные оптимизации.</p>
<h2 id="nagruzochnoe-testirovanie_1">Нагрузочное тестирование</h2>
<p>После оптимизации хорошей идеей будет провести нагрузочное тестирование, чтобы убедится, что уровень производительности
приложения соответствует реальной (или ожидаемой) нагрузке или SLA. Для этого типа тестирования вам потребуется окружение
аналогичное используемому на production. К счастью облачные сервисы и автоматизированная сборка проектов позволяют
разворачивать такое окружение за считанные минуты.</p>
<p>Рекомендую использовать <a href="http://locust.io/">Locust</a> для нагрузочного тестирования. Главное преимущество Locust,
что тесты описываются в виде Python кода. Можно настраивать сложные сценарии тестирования, чтобы максимально
приблизить нагрузку к той, которую генерируют реальные пользователи. Пример <code>locustfile.py</code>:</p>
<p>```python
from locust import HttpLocust, TaskSet, task</p>
<p>class UserBehavior(TaskSet):
    def on_start(self):
        """ on_start is called when a Locust start before any task is scheduled """
        self.login()</p>
<pre><code>def login(self):
    self.client.post("/login", {"username":"ellen_key", "password":"education"})

@task(2)
def index(self):
    self.client.get("/")

@task(1)
def profile(self):
    self.client.get("/profile")
</code></pre>
<p>class WebsiteUser(HttpLocust):
    task_set = UserBehavior
    min_wait = 5000
    max_wait = 9000
```</p>
<p>Также Locust предоставляет web-интерфейс для запуска тестов и просмотра результатов:</p>
<p><img alt="Locust web interface" src="/media/2017/6/locust-screenshot.png"/></p>
<p>Лучше всего то, что можно настроить Locust один раз и использовать для тестирования производительности после каждого
вносимого изменения. Возможно вы даже сможете добавить его в ваш CI/CD pipeline.</p>
<h2 id="nastroiki-django">Настройки Django</h2>
<p>В этом разделе мы рассмотрим настройки Django, которые могут повлиять на производительность.</p>
<h3 id="ttl-soedineniia-s-bd">TTL соединения с БД</h3>
<p>По умолчанию Django закрывает соединение с БД после завершения каждого запроса. Можно настроить TTL соединения с БД,
изменив значение параметра <a href="https://docs.djangoproject.com/en/1.11/ref/settings/#conn-max-age"><code>CONN_MAX_AGE</code></a>:</p>
<ul>
<li><code>0</code> - закрывать соединение после выполнения каждого запроса</li>
<li><code>&gt; 0</code> - TTL в секундах,</li>
<li><code>None</code> - неограниченное TTL.</li>
</ul>
<p><code>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
        'CONN_MAX_AGE': 60 * 10,  # 10 minutes
    }
}</code></p>
<h3 id="keshirovanie-shablonov">Кэширование шаблонов</h3>
<p>Если вам приходится использовать Django версии меньше чем 1.11, то вы можете рассмотреть включение кэширования шаблонов.
По умолчанию, Django (&lt;1.11) считывает и компилирует шаблоны каждый раз, когда они рендерятся. Можно использовать
загрузчик <code>django.template.loaders.cached.Loader</code> для включения кэширования шаблонов в памяти. Отредактируйте в 
<code>settings.py</code>:</p>
<p><code>TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'foo', 'bar'), ],
        'OPTIONS': {
            # ...
            'loaders': [
                ('django.template.loaders.cached.Loader', [
                    'django.template.loaders.filesystem.Loader',
                    'django.template.loaders.app_directories.Loader',
                ]),
            ],
        },
    },
]</code></p>
<h3 id="redis-kak-khranilishche-kesha">Redis как хранилище кэша</h3>
<p>Django предоставляет несколько вариантов хранилищ для кэша, например, БД, файловая система и тд. Рекомендую хранить кэш
в Redis - популярное хранилище объектов в памяти, с большой вероятностью вы уже используете его в своем проекте.
Для настройки Redis, как хранилища кэша нам нужно будет установить сторонний пакет, например <code>django-redis</code>.</p>
<p>Устанавливаем django-redis при помощи pip:</p>
<p><code>pip install django-redis</code></p>
<p>Добавьте настройки кэша в <code>settings.py</code>:</p>
<p><code>CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}</code></p>
<p>Читайте полную документацию <a href="http://niwinz.github.io/django-redis/latest/">здесь</a>.</p>
<h3 id="khranilishche-sessii">Хранилище сессий</h3>
<p>По умолчанию Django хранит сессии в БД. Для ускорения не помешает хранить сессии в кэше. Добавьте следующее
в <code>settings.py</code>:</p>
<p><code>SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"</code></p>
<h3 id="udalenie-nenuzhnykh-middleware">Удаление ненужных middleware</h3>
<p>Проверьте список используемых middleware (<code>MIDDLEWARE</code> в <code>settings.py</code>). Убедитесь, что там нет ничего не нужного.
Django вызывает каждый middleware для каждого обрабатываемого запроса, так что накладные расходы могут быть значительными.</p>
<p>Если у вас есть какой-либо кастомный middleware, который используется не для всех запросов, попробуйте вынести его
функциональность в mixin для view или декоратор. Это позволит избавится от задержек при обработке остальных запросов,
которые не требуют такой функциональности.</p>
  </div>
</section>
        <footer id="contentinfo" class="body">
            (c) 2010-2017
        </footer><!-- /#contentinfo -->
</body>
</html>