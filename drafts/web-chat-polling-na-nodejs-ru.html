<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="HandheldFriendly" content="true">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Web-чат polling на Node.JS</title>
    <link rel="stylesheet" href="/theme/css/native.css" />
    <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif&amp;subset=cyrillic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=PT+Mono&amp;subset=cyrillic" rel="stylesheet">
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-20497524-1', 'auto');
      ga('send', 'pageview');
    </script>
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
  styles: {
  ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
  },
  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']],processEscapes: true}
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body id="index" class="home">
        <header id="banner" class="body">
            <h1><a href="/">Tech blog by @dizballanze <strong></strong></a></h1>
            <div id="langs">
                <a href="/">En</a>
                <a href="/ru/">Ru</a>
            </div>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/about-me/">Author</a></li>
            <li><a href="https://wbtech.pro/">WB–Tech</a></li>
            <li><a href="https://debugmail.io/">DebugMail</a></li>
        </ul>
        </nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/drafts/web-chat-polling-na-nodejs-ru.html" rel="bookmark"
         title="Permalink to Web-чат polling на Node.JS">Web-чат polling на Node.JS</a></h2>
    <time class="published" datetime="2011-04-10T21:49:00+04:00"><nobr>10 апр 2011</nobr></time>
  </header>
  <div class="entry-content">
    <p><img alt="чат" src="/media/2011/04/conversacion-150x150.png" title="чат"/></p>
<p>Продолжим тему создания чата на Node.JS. На этот раз напишем чат,
который будет в качестве клиентов использовать браузеры.</p>
<h2 id="problema">Проблема</h2>
<p>Т.к. протокол HTTP не позволяет устанавливать постоянное соединение
сервера с клиентом, то нам необходимо самостоятельно инициировать
соединение для считывания новых сообщений. Для этого существует
множество способов, но мы для начала воспользуемся самым примитивным -
polling. Данный способ представляет собой постоянное опрашивание сервера
через определённые интервалы времени. Сразу хочу уточнить, что данный
способ ОЧЕНЬ не оптимален с точки зрения использования ресурсов сервера
и сетевого канала, но для обучающих целей он вполне пригоден. В реальных
приложениях стоит использовать более продвинутые средства, которые я
постараюсь в скором времени рассмотреть в этом блоге. Итак, поехали!</p>
<h2 id="struktura">Структура</h2>
<p>Сначала рассмотрим структуру нашего приложения:</p>
<ul>
<li>
<p><strong>Клиент</strong> - скрипт на jquery, который выполняет следующие функции:</p>
<ul>
<li>Отправка сообщения серверу</li>
<li>Запрос у сервера данных о новых сообщениях и их отображение</li>
</ul>
</li>
<li>
<p><strong>Сервер</strong> - скрипт на Node.js. Выполняет следующие функции:</p>
<ul>
<li>Добавляет присланные клиентами сообщения в массив сообщений</li>
<li>Отдает клиентам новые сообщения</li>
</ul>
</li>
</ul>
<h2 id="realizatsiia">Реализация</h2>
<h3 id="klientskaia-chast">Клиентская часть</h3>
<p>Для реализации клиентской части напишем небольшую страницу, которая
будет отвечать за визуализацию сообщений и их отправку. Весь код
приводить не буду, только интересные части:</p>
<pre><code>:::javascript
// ...
function load(){
    if ($(".message-row").size() == 0){
        var id = -1;
    }else{
        var id = $(".message-row:last").data('id');
    }

    $.getJSON('http://127.0.0.1:8124/?id=' + id + '&amp;callback=?', function(data){
        data = $.parseJSON(data);
        for (i in data){
            if ($("#mess" + data[i]['id']).size() == 0){
                $('&lt;div class="message-row" id="mess' + data[i]['id'] + '"&gt;' + data[i]['message'] + '&lt;/div&gt;').appendTo("#chat-body");
                $(".message-row:last").data('id', data[i]['id']);
            }
        }
        $("#chat-body").animate({ scrollTop: $("#chat-body").attr("scrollHeight") }, 3000);
    });
}
// ...
</code></pre>
<p>Данная функция будет отвечать за получение новых сообщений от сервера и
их визуализацию. Каждое сообщение будет идентифицироваться уникальным id
которое равно порядковому номеру сообщения. При визуализации каждое
сообщение помещается в div и к нему прикрепляется id при помощи
<a href="http://jqapi.com/#p=data">.data()</a>. Затем перед тем как запросить новые сообщения мы получаем
id последнего сообщения и помещаем его в запрос. В случае если сообщений
до запроса не было - передаем магическое число -1.</p>
<p>Т.к. наш сервер весит на специфическом порту, то для взаимодействия с
ним необходимо использовать cross domain ajax. Данный метод
подразумевает передачу последним параметром названия некой callback
функции. Генерацию этой функции берёт на себя jquery. Всё что нужно от
нас - это передать последним параметром в запросе ключ callback со
значением "?". Далее jquery заменит знак вопроса на название нашей
функции, которое он генерирует случайным образом. Всё что от нас
требовалось для реализации меж доменного ajax на стороне клиента мы
выполнили, особенности реализации на стороне сервера рассмотрим чуть
позже.</p>
<p>Рассмотрим остальной код:</p>
<pre><code>:::javascript
load();
setInterval(load, 2500);
</code></pre>
<p>Запускаем предварительную инициализацию списка сообщений и ставим
обработчик по таймеру, который будет вызываться каждые 2,5 секунды.</p>
<pre><code>:::javascript
// ....
$("#send-button").click(function(){
    if ($(".message-row").size() == 0){
        var id = -1;
    }else{
        var id = $(".message-row:last").data('id');
    }

    $.getJSON('http://127.0.0.1:8124/?message=' + $("input[name=message]").val() + '&amp;username=' + $("input[name=nick]").val() + '&amp;id=' + id + '&amp;callback=?', function(data){
        data = $.parseJSON(data);
        for (i in data){
            $('&lt;div class="message-row" id="mess' + data[i]['id'] + '"&gt;' + data[i]['message'] + '&lt;/div&gt;').appendTo("#chat-body");
            $(".message-row:last").data('id', data[i]['id']);
        }
        $("#chat-body").animate({ scrollTop: $("#chat-body").attr("scrollHeight") }, 3000);
    });
    $("input[name=message]").val('');
});
// ....
</code></pre>
<p>Ставим обработчик нажатия кнопки отправки сообщения. Здесь ничего
нового, просто такой же запрос как и в функции load за исключением того
что мы передаём дополнительные параметры - текст сообщения и псевдоним
пользователя.</p>
<h3 id="servernaia-chast">Серверная часть</h3>
<p>Тут начинается самое интересное :) Для реализации обмена по протоколу
HTTP в node.js есть одноименный модуль. Также мы будем использовать
модуль url для получения переданных нам параметров. Теперь рассмотрим
код, постараюсь как можно подробнее прокомментировать:</p>
<pre><code>:::javascript
// Подключение модулей
var http = require('http');
var url  = require('url');
// Массив сообщений
var messages = [];

// Создаем сервер и ставим обработчик запроса
http.createServer(function (request, response) { 
  // Получаем url
  var url_string = request.url;
  // Извлекаем параметры
  params = url.parse(url_string, true).query;

  // Если получено сообщение, то добавляем его в массив
  // предварительно объединив его с псевдонимом пользователя
  if (params.hasOwnProperty('message')){
      username = (params['username'].length == 0)?'guest':params['username'];
      message = params['message'];
      messages.push(username + ': ' + message);
  }

  // Извлекаем идентификатор сообщения
  var id = new Number(params['id']);
  var to, count, from = 0;
  // Получаем количество сообщений в массиве
  var len = messages.length;
  // Если пользователь только подключился,
  // то отдаём ему 10 последних сообщений
  if (id == -1){
      if (len &lt; 10){
          count = len;
          from = 0;
      }else {
          count = 10;
          from = len - 10;
      }
  // Иначе отдаем те сообщения которые были получены после 
  // сообщения с переданным идентификатором
  }else{
      count = len - id - 1;
      from = id + 1;
  }
  to = from + count - 1;
  // Формируем результирующий массив сообщений
  ret_messages = [];
  for (i = from; i &lt;= to; i++){
      ret_messages.push({message:messages[i], id:i});
  }

  // Кодируем массив в json
  body = JSON.stringify(ret_messages);
  // Устанавливаем заголовки ответа
  // Второй заголовок необходим для
  // cross domain ajax
  response.writeHead(200, {
    'Content-Type': 'application/json',
    "Access-Control-Allow-Origin": "*"
     });
  // Устанавливаем тело ответа и закрываем соединение
  // имитируем вызов метода
  response.end(params.callback + '(\'' + body + '\')'); 
// Вешаем сервер слушать 8124 порт на 127.0.0.1
}).listen(8124, "127.0.0.1"); 
console.log('Server running at http://127.0.0.1:8124/');
</code></pre>
<p>Всё достаточно прозрачно, кроме небольших заклинаний необходимых для
корректной работы cross domain ajax. Для того чтобы использовать чат в
сети поменяйте ip-адрес в 63 строке на свой внешний ip. Также не
забудьте поменять ip-адрес в клиенте.</p>
<p>Здесь можете найти архив с полным кодом приложения - <a href="stuff/web-chat-polling.zip">код</a></p>
<p>Спасибо за внимание, подписывайтесь на RSS, все вопросы в комментарии
ниже!</p>
  </div>
</section>
        <footer id="contentinfo" class="body">
            (c) 2010-2017
        </footer><!-- /#contentinfo -->
</body>
</html>