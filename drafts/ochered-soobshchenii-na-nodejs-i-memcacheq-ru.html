<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="HandheldFriendly" content="true">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Очередь сообщений на node.js и memcacheq</title>
    <link rel="stylesheet" href="/theme/css/native.css" />
    <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
    <link href="https://fonts.googleapis.com/css?family=PT+Serif&amp;subset=cyrillic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=PT+Mono&amp;subset=cyrillic" rel="stylesheet">
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-20497524-1', 'auto');
      ga('send', 'pageview');
    </script>
	
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
  styles: {
  ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
  },
  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']],processEscapes: true}
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body id="index" class="home">
        <header id="banner" class="body">
            <h1><a href="/">Tech blog by @dizballanze <strong></strong></a></h1>
            <div id="langs">
                <a href="/">En</a>
                <a href="/ru/">Ru</a>
            </div>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/about-me/">Author</a></li>
            <li><a href="https://wbtech.pro/">WB–Tech</a></li>
            <li><a href="https://debugmail.io/">DebugMail</a></li>
        </ul>
        </nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/drafts/ochered-soobshchenii-na-nodejs-i-memcacheq-ru.html" rel="bookmark"
         title="Permalink to Очередь сообщений на node.js и memcacheq">Очередь сообщений на node.js и memcacheq</a></h2>
    <time class="published" datetime="2011-10-07T23:24:00+04:00"><nobr>07 окт 2011</nobr></time>
  </header>
  <div class="entry-content">
    <p>Привет! Столкнулся с необходимостью использования очередей сообщений в
текущем проекте. Знаю что есть готовые решения, но я все же решил
написать свой небольшой велосипед. Итак, поехали...</p>
<h2 id="opisanie">Описание</h2>
<p><img alt="scheme" src="/media/2011/10/png"/></p>
<p>В поставленной передо мной задаче необходимо выполнять ресурсоемкие
операции (такие как работа с сетью, декодирование mp3-файлов), а также
обращаться к бизнес-логике приложения для потока входных данных.
Приложение написано на php, поэтому очевидно что удобнее всего писать
worker'ы на этом языке в виде cli скриптов. В моем случае это сделать
очень просто, т.к. в проекте используется yii, а в нем есть
замечательная поддержка написания консольных команд при этом можно
использовать весь код бизнес-логики используемый в основном приложении.</p>
<p>Для реализации хранения заданий отличным решением стало memcacheq.
Memcacheq - это сервис поддержки очередей с использованием api
memcached. Подробнее узнать о том что это за зверь можете на <a href="http://memcachedb.org/memcacheq/">офф.
сайте</a>. Стоит отметить что в связи с использованием BerkleyDB в
memcacheq есть ограничение на размер сообщения в очереди, которое
составляет около 64Кб, если для вас этого мало, то стоит подумать о
другом решении.</p>
<p>Также потребуется менеджер очереди, который будет контролировать работу
воркеров (порождать, отслеживать статус выполнения, получать
результаты). Очевидно что менеджер должен работать постоянно и
периодически проверять нет ли новых заданий. Для реализации менеджера я
выбрал Node.js, как мне кажется это очень подходящая технология для этих
целей. В основном выбор пал на node из-за его асинхронности, возможности
легко и быстро написать демон, который будет вписываться в архитектуру
проекта и также на меня повлиял предыдущий опыт работы с данной
технологией, который оставил в основном положительные впечатления.</p>
<h2 id="realizatsiia">Реализация</h2>
<p>На данном этапе у вас уже должен быть настроен и запущен memcacheq,
установлен nodejs. Также нам понадобиться модуль nodejs под названием
memcached. Установить его можно следующей командой:</p>
<pre><code>:::bash
npm install memcached
</code></pre>
<p>Основные составляющие части менеджера очереди:</p>
<ul>
<li>Бесконечный цикл опроса очереди на наличие заданий. При этом также в
    цикле должна проводиться проверка на состояние запущенных worker'ов.
    Т.к. мы не можем себе позволить создание worker'ов в таком
    количестве в котором доступны задания, то нам необходимо ввести
    ограничение на количество одновременно обрабатываемых заданий. В
    данном цикле перед созданием новых потоков проверяется наличие
    свободного места, т.е. worker создается только в случае если
    количество текущих worker'ов меньше установленного ограничения.</li>
<li>Объект worker'а - представляет из себя оболочку над процессом
    worker'а и хранит его состояние.</li>
<li>Создание worker'а - процесс инициализации объекта worker'а на основе
    данных полученных от memcacheq</li>
<li>Мониторинг. Для отслеживания состояния выполнения заданий создадим
    web-сервер который будет отвечать информацией о текущем статусе
    выполнения каждого выполняемого worker'а.</li>
<li>Т.к. в моя задача связанна с передачей большого объема данных, то
    появилось необходимость ввести поправку на возможную ошибку передачи
    данных. Это подразумевает повторное занесение задания в очередь в
    случае если worker вернет ошибку передачи, которая может быть
    определена проверкой контрольной суммы передаваемых данных.</li>
</ul>
<p>Теперь собственно исходный код:</p>
<pre><code>:::javascript
var util = require('util'),
    exec = require('child_process').exec;

var http = require('http');
var Memcached = require('./lib/memcached.js');
var memcached = new Memcached('127.0.0.1:22201', {maxValue:65000, reconnect:2000, retry:1000, timeout:10000});

var creating = false;
var workers_count = 2;
var transmit_error_retry_count = 3;
var workers = {};
var tasks = {};
var transmit_errors = {};
var command_line = '/path/to/worker/script';

// Возможные состояния процесса
var WORKER_SUCCESS_DONE = 1,
    WORKER_TRANSMIT_ERROR = 2,
    WORKER_CRITICAL_ERROR = 3,
    WORKER_IN_WORKING_PROCESS = 4;

// Функция выполняемая в бесконечном цикле
function check_feeds(){
    for (i in workers){
        if (workers[i].status == WORKER_SUCCESS_DONE){
            if (transmit_errors[i] != undefined)
                delete transmit_errors[i];
            delete workers[i];
            delete tasks[i];
        }else if(workers[i].status == WORKER_TRANSMIT_ERROR){
            if (transmit_errors[i] == undefined)
                transmit_errors[i] = 1;
            else
                transmit_errors[i]++;
            if (transmit_errors[i] &lt; transmit_error_retry_count)
                push_back(tasks[i]);
            else{
                delete transmit_errors[i];
                delete tasks[i];
            }
            delete workers[i];
        }else if (workers[i].status != WORKER_IN_WORKING_PROCESS){
            if (transmit_errors[i] != undefined)
                delete transmit_errors[i];
            delete workers[i];
        }
    }

    // Если есть свободные места вызываем функцию
    // создающую worker'ов
    if (!creating &amp;&amp; (obj_count(workers) &lt; workers_count))
        create_worker();
}

// Возвращение задания в очередь
function push_back(task){
    memcached.set("tracks", task, 0);
}

// Функция выполняющая создание новых worker'ов
function create_worker(){
    creating = true;
    memcached.get("tracks", function(err, result){
        if (!result)
            creating = false;
        else{
            check_feeds();
            work = JSON.parse(result);
            tasks[work['id']] = work;
            workers[work['id']] = new Worker(work);
            // Если все ещё есть свободные места
            // то делаем рекурсивный вызов
            if (obj_count(workers) &lt; workers_count){
                create_worker();
            }else{
                creating = false;
            }
        }
    });
}

// Конструктор объекта worker'а
function Worker(id, data){
    this.status = WORKER_IN_WORKING_PROCESS;

    // Здесь можно сформировать 
    // параметры командной строки
    var params;

    exec(command_line + params, function(err, data){
        console.log(id, data);
        if (err)
            workers[id].status = WORKER_CRITICAL_ERROR;
        else
            workers[id].status = data;
    })
}

setInterval(function(){
    check_feeds();
}, 100);

// Monitoring server
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    for (i in workers){
        res.write(i +': ' + workers[i].status + "\n");
    }
    // Для того чтобы заработал след. код
    // необходимо внести изменения
    // в модуль memcache (см. ниже)
    memcached.queue(function (err, result){
        res.end('Queue:' + result);
    });
}).listen(8080, "127.0.0.1");

// Stuff
function obj_count(obj){
    var i = 0;
    for (j in obj) i++;
    return i;
}
</code></pre>
<p>Для того чтобы корректно обрабатывать статусы выполнения задания
worker'ы должны возвращать определенные заранее значения. В моем случае
worker может вернуть одно из 3х состояний обозначенных в начале
исходного кода.</p>
<p>Также стоит отметить, что для реализации отображения количества задач в
очереди memcacheq необходимо выполнить запрос stats queue, но модуль
memcached по всей видимости его не поддерживает. По-этому я внес
небольшие дополнения чтобы реализовать данный функционал. Исходный код
модуля доступен <a href="http://pastebin.com/MgSFU6Gb">по ссылке</a>.</p>
<h2 id="in-the-end">In the end..</h2>
<p>Стоит заметить, что при помощи подобной организации системы вы сможете
распараллелить ресурсоемкие вычисления. Особенно это удобно, когда вам
необходимо обращаться к бизнес-логике написанной, например, на PHP. В
завершении хочу добавить что полученная система очереди сообщений сильно
направленная на реализацию поставленной передо мной задачи. Но я считаю,
что вы без проблем сможете доработать код для реализации нужного вам
функционала. Спасибо за внимание, буду рад ответить на возникшие
вопросы.</p>
  </div>
</section>
        <footer id="contentinfo" class="body">
            (c) 2010-2017
        </footer><!-- /#contentinfo -->
</body>
</html>