<!DOCTYPE html>
<html lang="en">
<head>
        <title>Эффективная совместная работа backend и frontend команд</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="/theme/css/app.css" type="text/css" />
        <link href="http://dizballanze.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tech blog by @dizballanze Atom Feed" />
        <link href="http://dizballanze.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Tech blog by @dizballanze RSS Feed" />
        <link href="/static/icons/favicon.ico" rel="icon" type="image/x-icon" />
        <link href="/static/icons/favicon.ico" rel="shortcut icon" type="image/x-icon" />
        
        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie.css"/>
                <script src="/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ru_RU/all.js#xfbml=1&appId=143995599087385";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<a href="https://github.com/dizballanze">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="/">Tech blog by @dizballanze </a></h1>
                <nav><ul>
                    <li><a href="/avtor/">Автор</a></li>
                    <li ><a href="/category/bd.html">БД</a></li>
                    <li class="active"><a href="/category/drugoe.html">Другое</a></li>
                    <li ><a href="/category/linux.html">Linux</a></li>
                    <li ><a href="/category/nodejs.html">Node.js</a></li>
                    <li ><a href="/category/python.html">Python</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/drafts/эффективная-совместная-работа-backend-и-frontend-команд.html" rel="bookmark"
           title="Permalink to Эффективная совместная работа backend и frontend команд">Эффективная совместная работа backend и frontend команд</a></h1>
<a href="http://twitter.com/share" class="twitter-share-button" data-width="80" data-count="horizontal" data-via="dizballanze" style="display:inline-block;">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

<div class="fb-like" data-send="false" data-layout="button_count" data-width="110" data-show-faces="true" data-font="trebuchet ms" style="display:inline-block;"></div>

<g:plusone size="medium" width="110" height="22" annotation="inline"></g:plusone>

<script type="text/javascript">
window.___gcfg = {
lang: 'en-US'
  };

  (function() {
var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
po.src = 'https://apis.google.com/js/plusone.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
})();
</script>

<!-- Put this script tag to the <head> of your page -->
<script type="text/javascript" src="//vk.com/js/api/openapi.js?75"></script>

<script type="text/javascript">
  VK.init({apiId: 2478358, onlyWidgets: true});
</script>

<!-- Put this div tag to the place, where the Like block will be -->
<div id="vk_like" style="display: inline-block; width: 110px;"></div>
<script type="text/javascript">
VK.Widgets.Like("vk_like", {type: "button"});
</script>    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-03-20T16:51:00+03:00">
                пт 20 марта 2015
        </abbr>
<p>категория: <a href="/category/drugoe.html">Другое</a>. </p>
<p>теги: <a href="/tag/collaboration/">collaboration</a><a href="/tag/vagrant/">vagrant</a><a href="/tag/git/">git</a><a href="/tag/rest/">REST</a></p>
</footer><!-- /.post-info -->      <p><img alt="teamwork" src="/media/2015/3/teamwork.jpg" title="Team work!" /></p>
<p>В <a href="http://wbtech.ru/">WB–Tech</a> мы любим разрабатывать проекты полного цикла, начиная от прототипов на салфетке и
заканчивая деплойем на продакшн сервер и дальнейшей поддержкой. Часть этапов разработки проекта идет последовательно, 
например, до того как будут собраны все требования и готово ТЗ, мы не начинаем писать код. Основная же часть 
процесса работы над проектом (непосредственно разработка) ведется параллельно backend и frontend командами. Такое 
распараллеливание значительно уменьшает календарный срок разработки проекта и улучшает конечный результат. Но также 
как в программировании, в управления проектами распараллеливание создает определенные трудности. 
Тому как мы решаем эти трудности и посвящен этот пост.</p>
<p>Пост можно разделить на 2 части: <a href="#_1">список инструментов и как мы их используем</a>, <a href="#web-">подходы к разработке</a>.</p>
<h2 id="_1">Инструменты</h2>
<p>Здесь только некоторые инструменты, используемые нами в процессе работы над проектом, я оставил только самые важные в 
контексте обсуждаемой проблемы.</p>
<h3 id="vagrant">Vagrant</h3>
<p>Поддерживать рабочее окружение крайне важная задача. Чем больше различий между рабочим окружением и продакшеном 
тем больше потенциальных багов из-за несовместимостей. Также, наверняка каждый опытный разработчик сталкивался с 
раздражающим типом багов "а на моей машине работает". Если backend разработчики обычно могут поддерживать рабочее 
окружение в актуальном состоянии, то для фронтендеров это более сложная задача, что естественно, т.к. это далеко 
от их профиля. Чтобы решить эту задачу раз и навсегда и предоставить всем разработчикам идентичное рабочее окружение 
и к тому же ускорить переключение между проектами и добавление к проекту новых разработчиков, мы используем 
<a href="https://www.vagrantup.com/">Vagrant</a>. </p>
<p>Vagrant позволяет получить рабочее окружение в одну команду <code>vagrant up</code> (при правильной настройке, этому будет посвящен 
отдельный пост), а используемый для настройки (provision) скрипт можно и нужно использовать для настройки 
production/staging/testing серверов. Vagrant поддерживает большое количество, т.н. provisioners, мы для себя выбрали 
<a href="http://www.ansible.com/">Ansible</a>, полученные скрипты для настройки сервера (playbook) используем при настройке всех 
окружений проекта с минимальными изменениями.</p>
<h3 id="github">GitHub</h3>
<p>Рассказывать зачем нужно использовать VCS (система управления версиями) я не буду, про это уже много писали. Расскажу как 
мы используем Git и GitHub для решения проблем возникающих при распараллеливании разработки. Мы используем технику 
<a href="https://guides.github.com/introduction/flow/">GitHub Flow</a>, каждая фича разрабатывается в отдельной ветке, затем создается 
Pull Request, который проходит code-review, автоматическое тестирование, ручное тестирование и после этого сливается в master, 
откуда уже попадает на продакшн сервер.</p>
<p>На самом деле все немного сложнее, рассмотрим разработку сферической фичи в вакууме (назовем ее фича1). 
Сначала мы разрабатываем backend код фичи1 по ТЗ в 
отдельном бранче <code>feature1</code>. После того, как разработчик решил что все готово и код можно проверять он пишет документацию 
по интеграции с фронтендом (API методы, формат входящих исходящих данных и обработка ошибок) и открывает Pull Request. 
После устранения недочетов и ошибок (без этого никак) бекенд версия считается стабильной и передается фронтенд команде (путем перевешивания задачи в BaseCamp), 
которая в этом же бранче дорабатывает фичу1 согласно спецификации полученной от бекенд команды. После этого PR проходит 
повторную проверку и после этого сливается в master и соответственно на продакшн.</p>
<p>Внимательный читатель может спросить, "а где же обещанное распараллеливание?". Чтобы ответить на этот вопрос я нарисовал 
небольшую картинку:</p>
<p><img alt="feature-flow" src="/media/2015/3/flow.png" title="Features flow!" /></p>
<p>Понятно, что это упрощенная модель и в реальной жизни все сложнее и нужно действовать гибко в зависимости от особенностей проекта, 
но в большинстве случаев это работает весьма эффективно.</p>
<h2 id="web-">Подходы к разработке web-проектов</h2>
<h3 id="hard-way-rest-api-spa">Hard way (REST Api, SPA)</h3>
<p>В сложных проектах, с большим количеством серверной логики и объемной предметной областью мы применяем подход основанный на 
разработке SPA и REST Api. Суть подхода в том, чтобы клиентская часть приложения (frontend) и серверная часть (backend) взаимодействовали 
через строго определенное Api. Такое разделение позволяет максимально распараллелить разработку и уменьшить зависимости между клиентским 
и серверным слоями.</p>
<p>На серверной стороне разрабатывается REST Api, бегло рассмотрим этот вопрос. API состоит из 
набора URI обслуживающих, т.н. ресурсы (они же сущности предметной области). Для каждого ресурса реализовывается определенный 
набор операций, в зависимости от того какие операции нужны клиенту. Кроме обычных CRUD (create/read/update/delete), могут быть 
реализованы также другие специфические операции, если того требует предметная область или если это существенно упрощает/ускоряет работу 
клиентского слоя. Данные при в запросах на сервер передаются или в GET параметрах или в теле запроса. Сервер же возвращает результат 
обработки запроса в http статус коде и подробный ответ в виде JSON документа в теле ответа. В итоге для работы с полученным API 
фронтенд разработчику нужно знать следующую информацию про каждое действие над ресурсом:</p>
<table>
<thead>
<tr>
<th>Описание</th>
<th>Пример</th>
</tr>
</thead>
<tbody>
<tr>
<td>URI</td>
<td>/users</td>
</tr>
<tr>
<td>HTTP метод</td>
<td><code>POST</code></td>
</tr>
<tr>
<td>Что делает</td>
<td>создает нового пользователя</td>
</tr>
<tr>
<td>Входящие данные</td>
<td><code>email</code> и <code>password</code> в теле запроса</td>
</tr>
<tr>
<td>Пример ответа</td>
<td>статус <code>200</code> и тело ответа <code>{"status": ok}</code></td>
</tr>
<tr>
<td>Обработка ошибок</td>
<td>статус <code>400</code> и тело ответа <code>{"email": "Указанный email уже зарегистрирован в системе"}</code></td>
</tr>
</tbody>
</table>
<p>Также в случае необходимости можно добавлять текстовое описание каких-либо тонкостей работы.</p>
<p>Используя известные характеристики Api, frontend команда может достаточно просто эмулировать работу бекенда (например, 
<a href="https://docs.angularjs.org/api/ngMock/service/$httpBackend">fake backend</a> для Angular.js) и работать не дожидаясь готового Api, а 
для подключения настоящего Api потребуется совсем не много времени.</p>
<p>Стоит также добавить, что при достаточном гранулированности Api доработка части новых фич может быть вообще без изменения 
серверного слоя, путем комбинирования и повторного использования существующих методов Api.</p>
<h3 id="simple-way-static-site">Simple way (static site)</h3>
<p>В случае если проект простой, например, небольшой промо-сайт с несколькими сущностями, которые можно редактировать в админке, 
то мы применяем подход основанный на генерации статического сайта. Конечный пользователь при этом взаимодействует 
только со статическими страницами (и возможно несколькими обработчиками форм), что также положительно влияет на скорости работы сайта. 
При изменении каких-либо данных в админке осуществялется перегенерация соответствующих страниц сайта.</p>
<p>При таком подходе совместная работа происходит очень просто. Выделяются части страниц, которые должны заполняться данными из админки, 
в отдельные подключаемые шаблоны, эти шаблоны затем рендерятся при изменении данных в админке и результат сохраняется в определенном 
месте, где его ищет и подключает сборщик статического сайта. Таким сборщиком, например, может быть <a href="http://gulpjs.com/">gulpjs</a>, используя 
плагины которого можно также оптимизировать изображения, компилировать coffee/sass и тд. В итоге для 
обновления верстки нужно только поменять шаблон и запустить сборщик статического сайта.</p>
<h2 id="_2">Заключение</h2>
<p>Спасибо всем, кто дочитал до конца. Если у вас возникли какие-то вопросы или вы хотите обсудить способ применяемый в вашей 
компании – пишите здесь в комментариях или твиттер <a href="https://twitter.com/dizballanze">@dizballanze</a>.</p>
    </div><!-- /.entry-content -->
    <div class="comments">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        var disqus_identifier = "drafts/эффективная-совместная-работа-backend-и-frontend-команд.html";
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://dizballanze.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
    </div>

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>ссылки</h2>
                        <ul>
                            <li><a href="http://wbtech.pro">WBTech</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>онлайн</h2>
                        <ul>
                            <li><a href="http://dizballanze.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            <li><a href="http://dizballanze.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate">rss feed</a></li>

                            <li><a href="https://twitter.com/dizballanze">Twitter</a></li>
                            <li><a href="https://github.com/dizballanze">GitHub</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Powered by <a href="http://getpelican.com/">Pelican</a>, <a href="http://python.org">Python</a>.
                <section class="right">&copy; <a href="/avtor">Yuri Shikanov</a> 2010-2015</section>
                </address><!-- /#about -->

        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-20497524-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'dizballanze';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>